/*
 * HP41C monitoring and control from Pico
 *
 */

#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>

#include "pico/stdlib.h"
//#include "hardware/i2c.h"
#include "hardware/gpio.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "pico/multicore.h"

////////////////////////////////////////////////////////////////////////////////
//
// Configuration flags
//

#define CF_DUMP_DBG_DREGS  0
#define CF_DISPLAY_LCD     1
#define CF_DISPLAY_OLED    1
#define CF_DBG_DISP_ON     0
#define CF_DBG_SLCT        0
#define CF_DBG_DISP_INST   0
#define CF_USE_DISP_ON     1
#define CF_DBG_KEY         1


#define MAX_KWB  50

#define PRESS_DELAY_1   50
#define PRESS_DELAY_2   2000

////////////////////////////////////////////////////////////////////////////////
//
// GPIO Pins
//

const uint P_KB_INH            = 0;
const uint P_KRA               = 1;
const uint P_KRB               = 2;
const uint P_KRC               = 3;

const uint P_KCA               = 4;
const uint P_KCB               = 5;
const uint P_KCC               = 6;

const uint P_CLK1              = 7;
const uint P_CLK2              = 8;

const uint P_DATA              = 9;
const uint P_ISA               = 10;
const uint P_SYNC              = 11;
const uint P_PWO               = 12;
const uint P_DATA_DRV          = 13;
const uint P_ISA_DRV           = 14;
const uint P_SYNC_DRV          = 15;
const uint P_FI_DRV            = 16;
const uint P_FI_OE             = 17;
const uint P_SYNC_OE           = 18;
const uint P_ISA_OE            = 19;
const uint P_DATA_OE           = 20;

// For the OLED display
const uint SDA_PIN             = 22;
const uint SCL_PIN             = 21;

volatile int core1_command = 0;

#ifndef I2C_FUNCTIONS_H_
#define I2C_FUNCTIONS_H_

typedef unsigned char BYTE;

// I2C Port descriptor
typedef struct _I2C_PORT_DESC
{
  unsigned char sdaport;
  unsigned char sdabit;
  unsigned char sclport;
  unsigned char sclbit;
} I2C_PORT_DESC;


// Slave device descriptor
typedef struct _I2C_SLAVE_DESC
{
  I2C_PORT_DESC *port;             // Port the device is on
  unsigned char slave_7bit_addr;        // SLave address
} I2C_SLAVE_DESC;


// I2C functions
void i2c_release(I2C_PORT_DESC *port);
void i2c_delay(I2C_PORT_DESC *port);
void i2c_sda_low(I2C_PORT_DESC *port);
void i2c_sda_high(I2C_PORT_DESC *port);
void i2c_scl_low(I2C_PORT_DESC *port);
void i2c_scl_high(I2C_PORT_DESC *port);
void i2c_start(I2C_PORT_DESC *port);
void i2c_stop(I2C_PORT_DESC *port);
int i2c_send_byte(I2C_PORT_DESC *port, BYTE b);
int i2c_read_bytes(I2C_SLAVE_DESC *slave, int n, BYTE *data);
void i2c_send_bytes(I2C_SLAVE_DESC *slave, int n, BYTE *data);
#


#endif /* I2C_FUNCTIONS_H_ */

// Memory that emulates a pak
typedef unsigned char BYTE;
typedef void (*FPTR)(void);
typedef void (*CMD_FPTR)(char *cmd);


// Serial loop command structure
typedef struct
{
  char key;
  char *desc;
  FPTR fn;
} SERIAL_COMMAND;

////////////////////////////////////////////////////////////////////////////////
//
// HP41C stuff
//
////////////////////////////////////////////////////////////////////////////////

// Bus instructions
// Beware: These are in octal

#define INST_DISPLAY_OFF               01340
#define INST_DISPLAY_TOGGLE            01440
#define INST_COMPENSATION_INSTRUCTION  01774
#define INST_C_PFAD                    01760
#define INST_WRITE_ANNUNCIATORS        01360
#define INST_READ_ANNUNCIATORS         00570
#define INST_SRLAD                     00050
#define INST_SRLDB                     00150
#define INST_SRLDC                     00250
#define INST_SRLDAB                    00350
#define INST_SRLDABC                   00450
#define INST_SLLDAB                    00550
#define INST_SLLDABC                   00650
#define INST_SRSDA                     00750
#define INST_SRSDB                     01050
#define INST_SRSDC                     01150
#define INST_SLSDA                     01250
#define INST_SLSDB                     01350
#define INST_SRSDAB                    01450
#define INST_SLSDAB                    01550
#define INST_SRSDABC                   01650
#define INST_SLSDABC                   01750
#define INST_PRPH_SLCT                 01760
#define INST_RAM_SLCT                  01160

#define INST_FLLDA                     00070
#define INST_FLLDB                     00170
#define INST_FLLDC                     00270
#define INST_FLLDAB                    00370
#define INST_FLLDABC                   00470
#define INST_FLSDC                     00670
#define INST_FRSDA                     00770
#define INST_FRSDB                     01070
#define INST_FRSDC                     01170
#define INST_FLSDA                     01270
#define INST_FLSDB                     01370
#define INST_FRSDAB                    01470
#define INST_FLSDAB                    01570
#define INST_FRSDABC                   01670
#define INST_FLSDABC                   01770

// bank switching instructions
#define INST_ENBANK1                   0x100
#define INST_ENBANK2                   0x180
#define INST_ENBANK3                   0x140
#define INST_ENBANK4                   0x1C0

#define INST_ENROM1                    0x1500
#define INST_ENROM2                    0x1980
#define INST_ENROM3                    0x1D40
#define INST_ENROM4                    0x1C0



#define MASK_48_BIT    (0xFFFFFFFFFFFFL)

int display_ce = 0;
char dtext[40];

#define ROTATE_RIGHT(V) {uint64_t t = (V & 0xF); V >>= 4; V |= t<<44;}
#define  ROTATE_LEFT(V) {uint64_t t = (V & (0xFLL << 44)); V <<= 4; V |= t>>44;}

////////////////////////////////////////////////////////////////////////////////
//
// Prototypes
//
//

void process_bus(void);

////////////////////////////////////////////////////////////////////////////////

// Where embedded ROM image is located
#define LOW_EMBED_ROM_ADDR   0x8000
#define HIGH_EMBED_ROM_ADDR  0x8FFF

// Do we drive ROM data?
int drive_data_flag = 0;

// The data we drive
int drive_data = 0;

// How many times have we driven ISA?
volatile int driven_isa = 0;
volatile int embed_seen = 0;
volatile int sync_count = 0;

char *embed_prog[] = {
		      // HP41C_EMBEDDED_PROG_START
"01 LBLGPHASE", "02 DEG", "03 XEQGJ0", "04 7.382647", "05 STO 03", "06 /", "07 INT", "08 STO 06", 
"09 ST* 03", "10 4", "11 MOD", "12 STO 04", "13 2", "14 STO 02", "15 XMY?", "16 ST- 02", 
"17 ST/ 02", "18 MOD", "19 STO 05", "20 221", "21 *", "22 RCL 02", "23 -", "24 407", 
"25 +", "26 RCL 06", "27 96.45423", "28 *", "29 21.6", "30 +", "31 STO 00", "32 SIN", 
"33 *", "34 RCL 06", "35 7.2763", "36 *", "37 2.6", "38 +", "39 STO 01", "40 SIN", 
"41 172", "42 RCL 02", "43 +", "44 *", "45 +", "46 RCL 05", "47 7", "48 *", 
"49 16", "50 -", "51 RCL 00", "52 ST+ X", "53 SIN", "54 *", "55 -", "56 RCL 05", 
"57 5", "58 -", "59 ST+ X", "60 RCL 06", "61 195.335", "62 *", "63 39", "64 -", 
"65 STO 02", "66 SIN", "67 *", "68 -", "69 RCL 05", "70 ST+ X", "71 7", "72 -", 
"73 RCL 00", "74 RCL 01", "75 -", "76 SIN", "77 *", "78 +", "79 RCL 05", "80 7", 
"81 *", "82 5", "83 +", "84 RCL 00", "85 RCL 01", "86 +", "87 SIN", "88 *", 
"89 +", "90 RCL 01", "91 ST+ X", "92 SIN", "93 ST+ X", "94 +", "95 RCL 05", "96 RCL 00", 
"97 RCL 02", "98 -", "99 SIN", "100 ST* Y", "101 +", "102 +", "103 RCL 04", "104 90", 
"105 *", "106 SIN", "107 3", "108 *", "109 +", "110 5598", "111 +", "112 E3", 
"113 /", "114 RCL 03", "115 +", "116 INT", "117 LASTX", "118 FRC", "119 X<0?", "120 DSE Y", 
"121 STO X", "122 24", "123 ST* Y", "124 MOD", "125 HMS", "126 X<>Y", "127 XEQGDT", "128 RCL 04", 

// HP41C_EMBEDDED_PROG_END
};

char *embed_keys[] = {
// HP41C_EMBEDDED_KEYS_START
"SHIFT", "STO", "ALPHA", "P", "H", "A", "S", "E", 
"ALPHA", "XEQ", "ALPHA", "D", "E", "G", "ALPHA", "XEQ", 
"ALPHA", "J", "SHIFT", "0", "ALPHA", "7", ".", "3", 
"8", "2", "6", "4", "7", "STO", "0", "3", 
"/", "XEQ", "ALPHA", "I", "N", "T", "ALPHA", "STO", 
"0", "6", "STO", "*", "0", "3", "4", "XEQ", 
"ALPHA", "M", "O", "D", "ALPHA", "STO", "0", "4", 
"2", "STO", "0", "2", "XEQ", "ALPHA", "X", "SHIFT", 
"H", "Y", "3", "ALPHA", "STO", "-", "0", "2", 
"STO", "/", "0", "2", "XEQ", "ALPHA", "M", "O", 
"D", "ALPHA", "STO", "0", "5", "2", "2", "1", 
"*", "RCL", "0", "2", "-", "4", "0", "7", 
"+", "RCL", "0", "6", "9", "6", ".", "4", 
"5", "4", "2", "3", "*", "2", "1", ".", 
"6", "+", "STO", "0", "0", "SIN", "*", "RCL", 
"0", "6", "7", ".", "2", "7", "6", "3", 
"*", "2", ".", "6", "+", "STO", "0", "1", 
"SIN", "1", "7", "2", "RCL", "0", "2", "+", 
"*", "+", "RCL", "0", "5", "7", "*", "1", 
"6", "-", "RCL", "0", "0", "STO", "+", ".", 
"X", "SIN", "*", "-", "RCL", "0", "5", "5", 
"-", "STO", "+", ".", "X", "RCL", "0", "6", 
"1", "9", "5", ".", "3", "3", "5", "*", 
"3", "9", "-", "STO", "0", "2", "SIN", "*", 
"-", "RCL", "0", "5", "STO", "+", ".", "X", 
"7", "-", "RCL", "0", "0", "RCL", "0", "1", 
"-", "SIN", "*", "+", "RCL", "0", "5", "7", 
"*", "5", "+", "RCL", "0", "0", "RCL", "0", 
"1", "+", "SIN", "*", "+", "RCL", "0", "1", 
"STO", "+", ".", "X", "SIN", "STO", "+", ".", 
"X", "+", "RCL", "0", "5", "RCL", "0", "0", 
"RCL", "0", "2", "-", "SIN", "STO", "*", ".", 
"Y", "+", "+", "RCL", "0", "4", "9", "0", 
"*", "SIN", "3", "*", "+", "5", "5", "9", 
"8", "+", "1", "EEX", "3", "/", "RCL", "0", 
"3", "+", "XEQ", "ALPHA", "I", "N", "T", "ALPHA", 
"XEQ", "ALPHA", "L", "A", "S", "T", "X", "ALPHA", 
"XEQ", "ALPHA", "F", "R", "C", "ALPHA", "XEQ", "ALPHA", 
"X", "SHIFT", "I", "SHIFT", "0", "3", "ALPHA", "XEQ", 
"ALPHA", "D", "S", "E", "ALPHA", ".", "Y", "STO", 
".", "X", "2", "4", "STO", "*", ".", "Y", 
"XEQ", "ALPHA", "M", "O", "D", "ALPHA", "XEQ", "ALPHA", 
"H", "M", "S", "ALPHA", "X<>Y", "XEQ", "ALPHA", "D", 
"T", "ALPHA", "RCL", "0", "4", 
// HP41C_EMBEDDED_KEYS_END
};

// Byte grabber keystrokes
char *byte_grabber_keys[] =
  {
#if 1
   "SHIFT","XEQ", "ALPHA", "SHIFT", "+", "ALPHA", "LN",
   "WAIT1",
   "SHIFT","XEQ", "ALPHA", "D", "E", "L", "ALPHA", "LOG",
   "WAIT1",
#endif   
   "PRGM",
   "WAIT1",
   "SHIFT",
   "WAIT1",
   "ENTER",
   "WAIT1",
   "1",
   "WAIT2",
   "R/S",
   "ALPHA",
   "<-",
  };

// Embedded ROM image

int embed_rom[] = {
		   
// HP41C_ROM_EMBEDDED_CODE_START
0x0001,0x002e,0x0000,0x0068,0x0200,0x006b,0x0200,0x00bd,0x0200,0x00ca,0x0200,0x00db,0x0201,0x009b,0x0203,0x006b,
0x0203,0x00ac,0x0203,0x00fb,0x0204,0x0044,0x0204,0x006e,0x0205,0x006c,0x0205,0x00f3,0x0207,0x00b6,0x0208,0x006e,
0x0209,0x0061,0x020a,0x00bc,0x020a,0x00e2,0x020a,0x00f6,0x020b,0x0003,0x020b,0x0010,0x020b,0x003d,0x020b,0x0056,
0x020b,0x0070,0x020b,0x0091,0x020b,0x00a6,0x020b,0x00bd,0x020b,0x00da,0x020b,0x00f4,0x020c,0x0003,0x020c,0x000e,
0x020c,0x0023,0x020c,0x0038,0x020c,0x004a,0x020c,0x005e,0x020c,0x006c,0x020c,0x007b,0x020c,0x008b,0x020c,0x009f,
0x020c,0x00b6,0x020c,0x00fb,0x020d,0x0037,0x020d,0x0062,0x020d,0x007d,0x020d,0x00f3,0x020f,0x0050,0x0000,0x0000,
0x0084,0x0031,0x0020,0x0008,0x0014,0x0002,0x000d,0x002d,0x03e0,0x008d,0x0230,0x01c0,0x0001,0x00f7,0x0000,0x004d,
0x0041,0x0054,0x0052,0x0049,0x0058,0x0112,0x001a,0x0010,0x0011,0x01cf,0x000f,0x01a9,0x00f3,0x0196,0x0073,0x01d0,
0x0007,0x000f,0x01a8,0x0004,0x01a8,0x0015,0x01a9,0x001d,0x01f7,0x004f,0x0052,0x0044,0x0045,0x0052,0x003d,0x003f,
0x018e,0x01cf,0x0010,0x0183,0x0151,0x0176,0x0112,0x0142,0x0140,0x0111,0x0014,0x0140,0x01a8,0x0019,0x0191,0x00f3,
0x01aa,0x0019,0x01b1,0x00b2,0x0111,0x0140,0x01f3,0x005a,0x0045,0x0020,0x019b,0x0073,0x019a,0x0073,0x01f6,0x0053,
0x0045,0x0054,0x0020,0x0053,0x0049,0x019b,0x0073,0x0177,0x018e,0x0175,0x01d0,0x002a,0x0010,0x01ca,0x000b,0x00f6,
0x0000,0x0053,0x0049,0x004d,0x0045,0x0051,0x01a9,0x0003,0x01a8,0x000a,0x01cc,0x0001,0x00f5,0x0000,0x0056,0x0043,
0x004f,0x004c,0x01a8,0x0005,0x01b2,0x0091,0x0101,0x0175,0x013e,0x01a8,0x000a,0x01c6,0x0002,0x00f5,0x0000,0x0056,
0x004d,0x0041,0x0054,0x01aa,0x0005,0x01a8,0x0008,0x0102,0x01ad,0x000a,0x018f,0x012e,0x01e3,0x004d,0x008e,0x0111,
0x0140,0x0130,0x0131,0x01d0,0x0013,0x0092,0x01cf,0x0011,0x01ad,0x000a,0x018f,0x01ac,0x0009,0x01d0,0x0009,0x0092,
0x012e,0x01e3,0x0038,0x008e,0x0111,0x0140,0x0131,0x01cf,0x0012,0x0173,0x01ac,0x0024,0x0118,0x01ac,0x0025,0x0114,
0x01ac,0x0026,0x0112,0x01ac,0x0027,0x0111,0x0140,0x0140,0x0140,0x019c,0x0000,0x01f1,0x0041,0x01ac,0x0005,0x01f1,
0x0042,0x01ac,0x0003,0x01f1,0x0058,0x01ac,0x0009,0x01f1,0x0043,0x01f1,0x007f,0x01ac,0x0005,0x01b3,0x0085,0x019b,
0x0000,0x01f2,0x007f,0x002c,0x0103,0x019b,0x0001,0x01f2,0x007f,0x003d,0x019c,0x00f3,0x01ac,0x0005,0x01b4,0x0090,
0x01ac,0x0009,0x01b4,0x008c,0x0120,0x0111,0x0141,0x012e,0x0142,0x0121,0x0140,0x0111,0x0014,0x0140,0x01b5,0x008f,
0x0104,0x012e,0x0151,0x0176,0x0140,0x0111,0x0014,0x0140,0x01ac,0x0005,0x0121,0x01ac,0x0009,0x0120,0x0140,0x0105,
0x01ad,0x000a,0x01b6,0x0088,0x01f2,0x007f,0x003f,0x018e,0x0191,0x00f2,0x01b7,0x0095,0x0106,0x019b,0x00f3,0x017e,
0x01aa,0x0006,0x0185,0x01ac,0x0005,0x01b7,0x008a,0x01ad,0x0009,0x01b7,0x0086,0x0196,0x0000,0x01d0,0x0077,0x0012,
0x0185,0x0107,0x0196,0x0001,0x01d0,0x007e,0x0012,0x01ac,0x0005,0x01b8,0x0085,0x0196,0x0000,0x01d0,0x0098,0x0011,
0x0108,0x01aa,0x0008,0x01a8,0x0005,0x01a9,0x000a,0x01cf,0x0013,0x0110,0x0185,0x01c6,0x001b,0x00f4,0x0000,0x0050,
0x0056,0x0054,0x01ad,0x0004,0x01d0,0x0022,0x0094,0x012e,0x0151,0x0111,0x0015,0x0140,0x0190,0x0073,0x012e,0x0140,
0x0111,0x0141,0x0111,0x001b,0x001c,0x0013,0x0142,0x0140,0x0110,0x013c,0x01cf,0x0023,0x0191,0x00f2,0x0196,0x0072,
0x01d0,0x0007,0x0023,0x01aa,0x0005,0x01a8,0x0007,0x01cf,0x0014,0x012e,0x0151,0x0111,0x0015,0x0140,0x0134,0x0111,
0x001b,0x001c,0x0013,0x012e,0x0111,0x0140,0x0140,0x0132,0x01ad,0x0004,0x01b9,0x0095,0x0176,0x012e,0x01e2,0x005b,
0x008e,0x0140,0x0133,0x0111,0x013d,0x0141,0x012e,0x0111,0x0014,0x0140,0x01e2,0x004f,0x008e,0x0111,0x0016,0x01ba,
0x0092,0x0109,0x0111,0x001a,0x0010,0x0010,0x0011,0x0133,0x012e,0x0151,0x0176,0x0140,0x0111,0x0015,0x0140,0x0183,
0x01e2,0x0039,0x008e,0x010a,0x0140,0x0137,0x0140,0x0138,0x012e,0x0151,0x0176,0x0111,0x014c,0x0141,0x0141,0x0111,
0x0015,0x0140,0x01e2,0x0027,0x008e,0x0111,0x0015,0x0140,0x01cf,0x0015,0x0135,0x01ac,0x0005,0x01bb,0x0082,0x0139,
0x013a,0x010b,0x0196,0x0073,0x01bc,0x008f,0x01ab,0x0004,0x01d0,0x00d6,0x009a,0x01ac,0x0007,0x01a8,0x0005,0x01aa,
0x0007,0x01d0,0x006b,0x0014,0x0185,0x010c,0x0136,0x01ad,0x0004,0x01be,0x00cf,0x01cf,0x0016,0x0190,0x0089,0x0161,
0x0190,0x008a,0x0161,0x0146,0x01bd,0x0082,0x012a,0x0139,0x010d,0x0196,0x000a,0x01d0,0x0011,0x0016,0x0125,0x0129,
0x0178,0x01b1,0x00cd,0x0127,0x0129,0x0125,0x0141,0x0168,0x0183,0x0171,0x012e,0x0143,0x0124,0x0140,0x0191,0x0084,
0x01ce,0x0004,0x0191,0x0084,0x01ce,0x0004,0x0175,0x0140,0x0176,0x01e1,0x00d0,0x008e,0x0140,0x0111,0x0141,0x013a,
0x0127,0x0111,0x0141,0x0139,0x01cf,0x0017,0x0190,0x0089,0x01ce,0x008a,0x01ce,0x0089,0x0196,0x0009,0x017f,0x0196,
0x000a,0x01d0,0x000e,0x0017,0x011c,0x0011,0x0194,0x000d,0x01b2,0x009a,0x010e,0x0124,0x0168,0x0190,0x0084,0x0163,
0x0178,0x01b2,0x0091,0x012e,0x0140,0x0171,0x012e,0x0140,0x0190,0x00f3,0x01ce,0x00f1,0x0191,0x00f2,0x01b2,0x0084,
0x0101,0x0124,0x0191,0x00f3,0x0102,0x0127,0x0139,0x0190,0x0085,0x0163,0x01d0,0x0011,0x0098,0x01cf,0x0021,0x01fb,
0x004e,0x004f,0x0020,0x0053,0x004f,0x004c,0x0055,0x0054,0x0049,0x004f,0x004e,0x018e,0x01cf,0x0018,0x0195,0x0089,
0x0196,0x0009,0x01d0,0x0007,0x0018,0x0127,0x0139,0x0128,0x013a,0x0196,0x0004,0x01cf,0x0019,0x0190,0x0089,0x0190,
0x0086,0x0142,0x0193,0x008a,0x0196,0x0009,0x017f,0x0196,0x000a,0x01d0,0x000f,0x0019,0x0128,0x0123,0x0111,0x01ad,
0x0004,0x0177,0x0141,0x0140,0x0138,0x013a,0x0127,0x0139,0x0196,0x0006,0x01d0,0x0020,0x0019,0x0127,0x0123,0x0140,
0x0137,0x0123,0x0111,0x01ad,0x0004,0x0177,0x0141,0x0140,0x0138,0x0125,0x0122,0x0140,0x01d0,0x00e5,0x0015,0x01cf,
0x001a,0x0197,0x0073,0x017f,0x0190,0x00f3,0x0167,0x01d0,0x005b,0x0021,0x0195,0x0087,0x012c,0x0132,0x012e,0x0151,
0x0176,0x0112,0x0142,0x0140,0x0111,0x0014,0x0140,0x0183,0x0133,0x0111,0x0141,0x01e1,0x001e,0x008e,0x0140,0x013a,
0x013c,0x0168,0x012e,0x0141,0x01e1,0x0015,0x008e,0x0123,0x0140,0x0111,0x0141,0x0139,0x0123,0x012e,0x0113,0x0142,
0x0141,0x013b,0x012e,0x0111,0x001b,0x0015,0x0143,0x0140,0x0133,0x01cf,0x001b,0x0190,0x008a,0x0190,0x008b,0x0142,
0x0193,0x0089,0x0197,0x000b,0x017f,0x0197,0x000a,0x01d0,0x000f,0x001b,0x011a,0x0010,0x0010,0x0011,0x0193,0x000c,
0x012c,0x013a,0x0197,0x0003,0x017f,0x0123,0x0168,0x013b,0x0197,0x0009,0x01d0,0x0022,0x001b,0x0122,0x013c,0x01ac,
0x0005,0x01a8,0x0003,0x01ad,0x0009,0x01ad,0x0002,0x01d2,0x0072,0x0011,0x0185,0x01c4,0x0042,0x00f4,0x0000,0x0044,
0x0045,0x0054,0x01aa,0x0005,0x01a8,0x0008,0x01ac,0x0004,0x01e1,0x00b2,0x0014,0x01aa,0x0008,0x01a8,0x0005,0x012e,
0x0111,0x0140,0x0111,0x001b,0x0015,0x0143,0x012e,0x0151,0x0111,0x0014,0x0140,0x01e0,0x00ae,0x008e,0x0140,0x0111,
0x0015,0x0140,0x012d,0x01cf,0x001c,0x0190,0x00f2,0x0142,0x0196,0x0072,0x01d0,0x0008,0x001c,0x01ac,0x0002,0x0185,
0x018f,0x01f4,0x0044,0x0045,0x0054,0x003d,0x019b,0x0073,0x017e,0x01d2,0x0013,0x0013,0x01c4,0x0009,0x00f4,0x0000,
0x0049,0x004e,0x0056,0x01a9,0x0005,0x01ac,0x0004,0x01e1,0x00f1,0x0014,0x012e,0x0151,0x0176,0x0140,0x0111,0x0015,
0x0140,0x013c,0x012e,0x0111,0x0141,0x0140,0x01e0,0x0073,0x008e,0x0192,0x000c,0x01cf,0x001d,0x012e,0x01e0,0x006b,
0x008e,0x0111,0x0140,0x01ad,0x0009,0x0131,0x0130,0x01a8,0x0009,0x01a9,0x000a,0x012c,0x0110,0x01cf,0x001e,0x0191,
0x00f2,0x0196,0x0072,0x01d0,0x0007,0x001e,0x0121,0x012c,0x0140,0x0111,0x0141,0x0111,0x0191,0x00f2,0x01e2,0x0028,
0x0014,0x017f,0x0196,0x0001,0x01d0,0x002a,0x001d,0x01a9,0x0009,0x0177,0x0185,0x01c4,0x000b,0x00f5,0x0000,0x0045,
0x0044,0x0049,0x0054,0x01aa,0x0005,0x01a8,0x0008,0x01a9,0x0016,0x01cf,0x001f,0x01fb,0x0052,0x004f,0x0057,0x0020,
0x005e,0x0020,0x0043,0x004f,0x004c,0x003d,0x003f,0x018e,0x017f,0x01ab,0x0016,0x01b3,0x0095,0x0131,0x0171,0x0130,
0x01cf,0x0020,0x01a8,0x0006,0x01e3,0x001e,0x0012,0x0184,0x01ab,0x0016,0x01d0,0x0022,0x001f,0x0191,0x00f2,0x01d0,
0x0010,0x0020,0x0103,0x01aa,0x0008,0x01a8,0x0005,0x01d2,0x00a1,0x0013,0x010f,0x0111,0x001b,0x0013,0x0143,0x01ca,
0x0009,0x0220,0x002a,0x0270,0x01c6,0x0000,0x00f6,0x0000,0x0053,0x004f,0x004c,0x0056,0x0045,0x01a8,0x0015,0x01a9,
0x0016,0x01a0,0x006d,0x019a,0x0006,0x018b,0x01cf,0x0067,0x01f9,0x0047,0x0055,0x0045,0x0053,0x0053,0x0020,0x0031,
0x003d,0x003f,0x018e,0x01aa,0x0016,0x01d0,0x0029,0x00e6,0x0111,0x0131,0x0111,0x0010,0x0132,0x0102,0x01c0,0x0006,
0x00f4,0x0000,0x0053,0x004f,0x004c,0x01e0,0x005c,0x00e8,0x01ac,0x0000,0x01b1,0x00a4,0x01fd,0x004e,0x004f,0x0020,
0x0052,0x004f,0x004f,0x0054,0x0020,0x0046,0x004f,0x0055,0x004e,0x0044,0x017e,0x0185,0x01d0,0x0037,0x0067,0x01cf,
0x0066,0x0131,0x01f9,0x0047,0x0055,0x0045,0x0053,0x0053,0x0020,0x0032,0x003d,0x003f,0x018e,0x0132,0x01b2,0x0033,
0x0101,0x01f8,0x0052,0x004f,0x004f,0x0054,0x0020,0x0049,0x0053,0x0020,0x0121,0x0122,0x0178,0x01b1,0x009b,0x01f9,
0x007f,0x0042,0x0045,0x0054,0x0057,0x0045,0x0045,0x004e,0x0020,0x019b,0x0073,0x018c,0x017e,0x01f4,0x0041,0x004e,
0x0044,0x0020,0x019b,0x0072,0x018b,0x017e,0x0185,0x01d0,0x0072,0x0067,0x0101,0x019b,0x0073,0x017e,0x0185,0x01d0,
0x007a,0x0067,0x01cf,0x0068,0x01a9,0x0000,0x0121,0x0133,0x0103,0x01ae,0x0086,0x0167,0x01b7,0x0000,0x01ac,0x0000,
0x01b4,0x0087,0x0134,0x0122,0x0133,0x01a8,0x0000,0x01b3,0x0011,0x0104,0x01a9,0x0000,0x0135,0x0124,0x0178,0x0185,
0x0141,0x0176,0x0143,0x0166,0x01b4,0x008e,0x0176,0x0130,0x0121,0x0133,0x0105,0x0122,0x0131,0x0125,0x0106,0x0134,
0x0120,0x0135,0x0123,0x0132,0x0104,0x0122,0x0121,0x0122,0x0141,0x0124,0x0125,0x0143,0x0167,0x01ac,0x0000,0x0164,
0x01b4,0x0087,0x01a8,0x0000,0x0111,0x001b,0x001c,0x0019,0x0141,0x0104,0x0111,0x0141,0x0164,0x01b4,0x0085,0x01ac,
0x0000,0x01b4,0x0081,0x0185,0x0104,0x0143,0x0141,0x0179,0x01b4,0x008d,0x0121,0x0141,0x0119,0x01ac,0x0000,0x0152,
0x01ac,0x0000,0x0154,0x0143,0x0140,0x0178,0x0185,0x0104,0x0133,0x01ae,0x0086,0x0167,0x01b7,0x00a3,0x0130,0x0125,
0x0171,0x0143,0x01ac,0x0000,0x0166,0x01b5,0x004d,0x0111,0x0141,0x0121,0x0123,0x0141,0x0176,0x0122,0x0141,0x0143,
0x0142,0x0111,0x0141,0x0111,0x001b,0x001c,0x0013,0x0146,0x0171,0x0176,0x0145,0x0171,0x0154,0x0120,0x0142,0x01b6,
0x0063,0x0107,0x01a8,0x0000,0x0123,0x0131,0x0132,0x01c8,0x0023,0x0220,0x0054,0x0230,0x01c0,0x0001,0x00f5,0x0000,
0x0050,0x004f,0x004c,0x0059,0x01a8,0x0015,0x01a8,0x0000,0x01a9,0x0003,0x01f8,0x0044,0x0045,0x0047,0x0052,0x0045,
0x0045,0x003d,0x003f,0x018e,0x0191,0x0016,0x0111,0x0191,0x0096,0x0190,0x0016,0x0111,0x0141,0x0191,0x0015,0x0106,
0x01a9,0x001d,0x01f1,0x0061,0x019c,0x0000,0x01f1,0x007f,0x019b,0x0015,0x01f3,0x007f,0x003d,0x003f,0x01a8,0x001d,
0x019c,0x0004,0x018e,0x0191,0x0095,0x0197,0x0015,0x01b6,0x001a,0x01f4,0x0061,0x0030,0x003d,0x003f,0x018e,0x0130,
0x01f6,0x0052,0x004f,0x004f,0x0054,0x0053,0x003f,0x018c,0x018e,0x019a,0x0072,0x01f1,0x004e,0x019a,0x0073,0x018b,
0x0179,0x01d0,0x002f,0x00e7,0x01f3,0x0058,0x003d,0x003f,0x018e,0x01cf,0x0066,0x0190,0x0016,0x0191,0x0015,0x0171,
0x0183,0x0183,0x0183,0x0190,0x0095,0x0197,0x0015,0x0102,0x0142,0x0190,0x0095,0x0140,0x0197,0x0015,0x01b2,0x0009,
0x0142,0x0120,0x0140,0x01f4,0x0046,0x003c,0x0058,0x003e,0x01f2,0x007f,0x003d,0x019b,0x0073,0x018e,0x01d0,0x0026,
0x0066,0x01cf,0x0067,0x01c4,0x0013,0x00f6,0x0000,0x0052,0x004f,0x004f,0x0054,0x0053,0x0120,0x0136,0x0121,0x0137,
0x0122,0x0138,0x0123,0x0139,0x0124,0x013a,0x0190,0x0016,0x0115,0x0178,0x01d0,0x001a,0x00e7,0x0177,0x0114,0x0178,
0x01d0,0x0035,0x00e8,0x0177,0x0113,0x0178,0x01d0,0x00ba,0x00e9,0x0177,0x0112,0x0178,0x01d0,0x00d3,0x00ea,0x01f3,
0x004e,0x003e,0x0035,0x018e,0x0185,0x01cf,0x0067,0x0111,0x0010,0x001a,0x0010,0x0010,0x0016,0x0191,0x0014,0x0191,
0x0015,0x01e1,0x0016,0x00fb,0x012d,0x01e0,0x00dc,0x0084,0x012a,0x0111,0x01e1,0x005a,0x00fc,0x01e1,0x0057,0x00fc,
0x01e1,0x0054,0x00fc,0x01e1,0x0051,0x00fc,0x01cf,0x0068,0x0128,0x0191,0x0012,0x0154,0x0138,0x0127,0x0191,0x0011,
0x0129,0x0191,0x0013,0x0142,0x0126,0x0191,0x0010,0x0114,0x0142,0x0141,0x0137,0x0190,0x0012,0x0114,0x0142,0x0190,
0x0013,0x0151,0x0141,0x0190,0x0010,0x0142,0x0190,0x0011,0x0151,0x0141,0x0136,0x01a9,0x0000,0x01e0,0x0063,0x00e9,
0x01aa,0x0003,0x0185,0x0103,0x01aa,0x0002,0x01b1,0x0088,0x012d,0x0129,0x0145,0x013d,0x012d,0x012a,0x0145,0x013d,
0x0101,0x0190,0x0013,0x013c,0x0112,0x0195,0x000c,0x0195,0x000d,0x012d,0x0151,0x0190,0x0010,0x0141,0x0166,0x0110,
0x0000,0x0111,0x001b,0x001c,0x0018,0x0145,0x01e0,0x0035,0x0086,0x0175,0x0152,0x013f,0x012c,0x012d,0x0142,0x0190,
0x0011,0x0112,0x0143,0x0141,0x0167,0x0111,0x0183,0x0161,0x0143,0x013e,0x012c,0x0151,0x0190,0x0012,0x0141,0x012d,
0x0112,0x0142,0x0140,0x0152,0x0194,0x000e,0x01a8,0x0000,0x01e0,0x0002,0x0087,0x0108,0x012c,0x012e,0x0154,0x013e,
0x0140,0x0137,0x012d,0x012f,0x0154,0x013f,0x0140,0x0136,0x01e0,0x0027,0x00ea,0x0185,0x0107,0x0171,0x0177,0x0171,
0x0185,0x01cf,0x0069,0x0118,0x001a,0x0010,0x0010,0x0016,0x0191,0x0014,0x0191,0x0015,0x01e0,0x006b,0x00fb,0x01ac,
0x0003,0x0185,0x012d,0x01ac,0x0000,0x01e0,0x002c,0x0084,0x0128,0x0111,0x01e0,0x00aa,0x00fc,0x01e0,0x00a7,0x00fc,
0x01cf,0x006a,0x0127,0x0154,0x0112,0x0143,0x0183,0x0183,0x0151,0x0126,0x0141,0x0166,0x01b1,0x00a0,0x0152,0x0140,
0x0139,0x01ac,0x0000,0x01e0,0x000e,0x0084,0x0174,0x0176,0x0141,0x013a,0x01ac,0x0000,0x01e0,0x0005,0x0084,0x01a9,
0x0002,0x0185,0x0105,0x01f5,0x0052,0x004f,0x004f,0x0054,0x003d,0x019b,0x0073,0x017e,0x017f,0x0185,0x0101,0x0154,
0x0152,0x013b,0x0174,0x012b,0x0154,0x01ac,0x0000,0x01e0,0x0005,0x0086,0x01a8,0x0002,0x0185,0x0107,0x01f2,0x0055,
0x003d,0x019b,0x0070,0x017e,0x01f2,0x0056,0x003d,0x019b,0x0071,0x017e,0x01f2,0x0055,0x003d,0x019b,0x0072,0x017e,
0x01f3,0x002d,0x0056,0x003d,0x019b,0x0073,0x017e,0x0185,0x01cf,0x007b,0x0110,0x013d,0x0126,0x0183,0x0161,0x0167,
0x01b4,0x00d1,0x0143,0x013e,0x0176,0x0190,0x0095,0x0161,0x0140,0x0156,0x0168,0x0111,0x0140,0x0157,0x0111,0x0146,
0x0171,0x013c,0x010a,0x0111,0x0010,0x0195,0x000c,0x012e,0x0154,0x013e,0x0109,0x012d,0x012d,0x012c,0x012e,0x0142,
0x0140,0x013d,0x0178,0x0185,0x0183,0x0183,0x01e0,0x000b,0x00fd,0x0167,0x0185,0x012e,0x0142,0x0166,0x01b9,0x0016,
0x01ba,0x0020,0x01cf,0x007d,0x0190,0x0095,0x0140,0x0142,0x0197,0x0015,0x01d0,0x0009,0x007d,0x0126,0x0140,0x0190,
0x0014,0x0191,0x0015,0x0175,0x0185,0x01cf,0x007c,0x0197,0x0015,0x0101,0x012d,0x0142,0x0140,0x0190,0x0095,0x0171,
0x0191,0x0095,0x0185,0x0104,0x01a8,0x0003,0x0110,0x013d,0x0127,0x0136,0x0128,0x0137,0x01e0,0x00bd,0x006a,0x01b3,
0x0000,0x01ca,0x003f,0x0220,0x001a,0x0270,0x01c6,0x0000,0x00f5,0x0000,0x0049,0x004e,0x0054,0x0047,0x0177,0x01a8,
0x0015,0x01a8,0x001b,0x0184,0x01cf,0x0066,0x0134,0x0185,0x01cf,0x0067,0x0130,0x0136,0x0110,0x0133,0x0105,0x0185,
0x01cf,0x0067,0x0131,0x01e0,0x0090,0x0081,0x0183,0x0140,0x0192,0x0006,0x0111,0x0192,0x0003,0x0123,0x0185,0x01cf,
0x0067,0x0131,0x01e0,0x0081,0x0081,0x0192,0x0006,0x0111,0x0192,0x0003,0x0123,0x01b5,0x001f,0x01cf,0x0068,0x0112,
0x0120,0x01b1,0x0088,0x01cf,0x0069,0x0123,0x01e0,0x0015,0x0082,0x0113,0x0126,0x0101,0x0121,0x0141,0x0106,0x0124,
0x0142,0x0171,0x0143,0x0198,0x0073,0x0185,0x01cf,0x007b,0x0132,0x0171,0x0131,0x0185,0x0103,0x0112,0x0143,0x0169,
0x0163,0x01d0,0x003e,0x00ea,0x0185,0x01cf,0x007c,0x0133,0x01e0,0x000d,0x0002,0x01a0,0x006d,0x019a,0x0007,0x018b,
0x0121,0x01ae,0x0087,0x0130,0x0122,0x01ae,0x0087,0x0192,0x0000,0x0122,0x0121,0x0135,0x0141,0x0123,0x0143,0x0134,
0x0110,0x0136,0x0104,0x01e0,0x0011,0x0086,0x0192,0x0000,0x0112,0x0192,0x0006,0x0123,0x0126,0x0178,0x01b1,0x009f,
0x01e0,0x0004,0x0086,0x01b4,0x0013,0x0107,0x0124,0x0192,0x0005,0x0125,0x01ae,0x0087,0x01e0,0x0017,0x0081,0x0185,
0x01cf,0x006a,0x01fa,0x004e,0x0020,0x004e,0x004f,0x0054,0x0020,0x0045,0x0056,0x0045,0x004e,0x018e,0x0185,0x0101,
0x0113,0x0120,0x01b6,0x0066,0x0102,0x0183,0x0140,0x0192,0x0000,0x01c8,0x0019,0x0220,0x0023,0x0230,0x01c0,0x0001,
0x00f6,0x0000,0x0044,0x0049,0x0046,0x0045,0x0051,0x01a8,0x0015,0x01a0,0x006d,0x019a,0x0007,0x01f7,0x004f,0x0052,
0x0044,0x0045,0x0052,0x003d,0x003f,0x018b,0x018e,0x0111,0x0178,0x01a9,0x0001,0x0177,0x0112,0x0178,0x01a8,0x0001,
0x01fb,0x0053,0x0054,0x0045,0x0050,0x0020,0x0053,0x0049,0x005a,0x0045,0x003d,0x003f,0x018e,0x0112,0x0143,0x0131,
0x01f4,0x0058,0x0030,0x003d,0x003f,0x018e,0x0132,0x01f4,0x0059,0x0030,0x003d,0x003f,0x018e,0x0133,0x01ac,0x0001,
0x01e0,0x0038,0x0080,0x010a,0x0123,0x0122,0x01ae,0x0087,0x01e0,0x00a0,0x0087,0x0135,0x01e0,0x007d,0x0084,0x0136,
0x01e0,0x0079,0x0084,0x0192,0x0006,0x0183,0x0140,0x0123,0x0140,0x0122,0x0121,0x0183,0x0140,0x0134,0x0140,0x01ae,
0x0087,0x01e0,0x0087,0x0087,0x0125,0x0140,0x0126,0x0183,0x0140,0x0140,0x0113,0x0143,0x0192,0x0003,0x0124,0x0192,
0x0002,0x018f,0x0198,0x0002,0x0198,0x0003,0x017f,0x01ba,0x0036,0x0101,0x01f5,0x0059,0x0030,0x002e,0x003d,0x003f,
0x018e,0x0134,0x010b,0x0124,0x0123,0x0122,0x01ae,0x0087,0x01e0,0x0060,0x0087,0x0135,0x0130,0x0121,0x01e0,0x0047,
0x0086,0x0136,0x0130,0x0121,0x0120,0x0124,0x0140,0x0125,0x01e0,0x0042,0x0085,0x0192,0x0006,0x0183,0x0140,0x0130,
0x0121,0x0183,0x0140,0x01e0,0x0032,0x0086,0x0126,0x0183,0x0140,0x0140,0x0125,0x0140,0x0113,0x0143,0x0124,0x0140,
0x0134,0x0176,0x0126,0x0125,0x0140,0x0113,0x0143,0x0140,0x0121,0x0183,0x0140,0x0135,0x0142,0x0192,0x0003,0x0125,
0x0192,0x0002,0x018f,0x0198,0x0002,0x0198,0x0003,0x017f,0x01bb,0x0048,0x0105,0x0123,0x0140,0x0122,0x0121,0x0140,
0x01ae,0x0087,0x01e0,0x0016,0x0087,0x0185,0x0107,0x0120,0x0124,0x0140,0x0120,0x0106,0x0112,0x0143,0x0124,0x0140,
0x0174,0x0142,0x0123,0x0140,0x0122,0x0174,0x0140,0x01ae,0x0087,0x0108,0x0121,0x0142,0x01c0,0x0022,0x0220,0x0032,
0x0220,0x01c2,0x0001,0x00f5,0x0000,0x0046,0x004f,0x0055,0x0052,0x01a8,0x0015,0x0181,0x0112,0x0010,0x0000,0x0110,
0x010b,0x0191,0x00f2,0x0197,0x0072,0x01bb,0x0007,0x01fd,0x004e,0x004f,0x002e,0x0020,0x0053,0x0041,0x004d,0x0050,
0x004c,0x0045,0x0053,0x003d,0x003f,0x018e,0x0191,0x0019,0x01fa,0x004e,0x004f,0x002e,0x0020,0x0046,0x0052,0x0045,
0x0051,0x003d,0x003f,0x018e,0x0112,0x0142,0x0191,0x0016,0x01fb,0x0031,0x0053,0x0054,0x0020,0x0043,0x004f,0x0045,
0x0046,0x0046,0x003d,0x003f,0x018e,0x0191,0x0018,0x0111,0x0130,0x019c,0x0000,0x0101,0x01a9,0x001d,0x01f1,0x0059,
0x019b,0x0000,0x01f3,0x007f,0x003d,0x003f,0x01a8,0x001d,0x018e,0x0106,0x0191,0x0017,0x0190,0x0016,0x0191,0x0015,
0x0102,0x0177,0x0120,0x01e0,0x0040,0x0087,0x0190,0x0019,0x0143,0x0142,0x0112,0x0142,0x0172,0x0142,0x0171,0x014e,
0x0192,0x0095,0x0171,0x0197,0x0015,0x0192,0x0095,0x0190,0x0017,0x0183,0x0197,0x0015,0x01b2,0x001e,0x0111,0x0192,
0x0000,0x0190,0x0019,0x0120,0x0146,0x01b1,0x003c,0x01f5,0x0052,0x0045,0x0043,0x0054,0x003f,0x018c,0x018e,0x018b,
0x019a,0x0072,0x01f1,0x004e,0x019a,0x0073,0x0179,0x01d0,0x0019,0x00e6,0x01cf,0x0067,0x01a8,0x0001,0x0190,0x0016,
0x0191,0x0015,0x01b3,0x0095,0x0108,0x0190,0x0015,0x0190,0x0016,0x0141,0x011c,0x0012,0x0143,0x0190,0x0018,0x0140,
0x0185,0x01cf,0x0066,0x01a9,0x0001,0x0190,0x0016,0x0191,0x0015,0x0103,0x01e0,0x0017,0x0007,0x0191,0x001a,0x0190,
0x0095,0x0197,0x0015,0x0190,0x0095,0x01ac,0x0001,0x01b4,0x00b1,0x0112,0x0190,0x0019,0x0143,0x0142,0x0171,0x0176,
0x0142,0x0105,0x019c,0x0000,0x01f1,0x0061,0x01e0,0x0014,0x0089,0x019b,0x0073,0x017e,0x019c,0x0000,0x01f1,0x0062,
0x01e0,0x000a,0x0089,0x019b,0x0072,0x017e,0x0197,0x0015,0x01b3,0x0031,0x0185,0x010a,0x01a9,0x001d,0x019b,0x001a,
0x01f2,0x007f,0x003d,0x019c,0x0004,0x01f1,0x007f,0x01a8,0x001d,0x0185,0x0104,0x0171,0x014f,0x0112,0x0190,0x0019,
0x0143,0x0142,0x019c,0x0000,0x01f1,0x0063,0x01e0,0x001c,0x0009,0x019b,0x0073,0x017e,0x019c,0x0000,0x01f1,0x000d,
0x01e0,0x0026,0x0009,0x019b,0x0072,0x017e,0x0197,0x0015,0x01b3,0x0061,0x0185,0x01cf,0x006a,0x01a9,0x0002,0x0130,
0x0190,0x0016,0x0191,0x0015,0x0177,0x0107,0x01e0,0x0083,0x0007,0x0167,0x01a8,0x0002,0x0112,0x0142,0x0172,0x0142,
0x0120,0x0142,0x0190,0x0019,0x0143,0x0111,0x01aa,0x0002,0x01e0,0x001a,0x0088,0x014e,0x0190,0x0095,0x0142,0x0171,
0x0197,0x0015,0x0190,0x0095,0x0142,0x0140,0x0190,0x0019,0x0143,0x0112,0x0142,0x0140,0x0197,0x0015,0x01b7,0x002b,
0x0198,0x0073,0x0185,0x0109,0x0177,0x011a,0x0015,0x01cc,0x0030,0x0220,0x0039,0x0240,0x01cc,0x0000,0x00f4,0x0000,
0x005a,0x005e,0x004e,0x0180,0x0130,0x0175,0x014f,0x0120,0x0153,0x0171,0x0120,0x0142,0x0171,0x0105,0x014e,0x0101,
0x01ac,0x0004,0x0185,0x01a8,0x0015,0x01f2,0x0055,0x003d,0x019b,0x0073,0x017e,0x01f2,0x0056,0x003d,0x019b,0x0072,
0x017e,0x0185,0x01c6,0x0005,0x00f5,0x0000,0x004d,0x0041,0x0047,0x005a,0x014f,0x01a8,0x0015,0x01f2,0x0052,0x003d,
0x019b,0x0073,0x01ad,0x0004,0x017e,0x0185,0x01cc,0x0002,0x00f4,0x0000,0x0065,0x005e,0x005a,0x0181,0x0155,0x014e,
0x0180,0x01b1,0x0034,0x01cc,0x0001,0x00f4,0x0000,0x004c,0x004e,0x005a,0x0181,0x014f,0x0150,0x0180,0x01b1,0x0041,
0x01cc,0x0001,0x00f6,0x0000,0x005a,0x005e,0x0031,0x002f,0x004e,0x0180,0x0130,0x0113,0x0016,0x0010,0x0171,0x0143,
0x0131,0x0175,0x014f,0x0120,0x0168,0x0160,0x0153,0x0171,0x0120,0x0168,0x0143,0x0171,0x0104,0x01e0,0x0061,0x0004,
0x0197,0x0000,0x01b2,0x0081,0x0185,0x0102,0x014f,0x0171,0x0121,0x0140,0x0171,0x01b4,0x0011,0x01c6,0x0006,0x00f5,
0x0000,0x0053,0x0049,0x004e,0x005a,0x0181,0x0132,0x015a,0x0171,0x0133,0x01a0,0x0061,0x0142,0x0122,0x0159,0x0123,
0x01a0,0x0062,0x0142,0x0180,0x01b1,0x0000,0x01c8,0x0003,0x00f5,0x0000,0x0043,0x004f,0x0053,0x005a,0x0181,0x0132,
0x0159,0x0171,0x0133,0x01a0,0x0061,0x0142,0x0154,0x0122,0x015a,0x0123,0x01a0,0x0062,0x0142,0x0180,0x01b1,0x0000,
0x01ca,0x0003,0x00f5,0x0000,0x0054,0x0041,0x004e,0x005a,0x0181,0x0112,0x0142,0x0132,0x015a,0x0171,0x0112,0x0142,
0x0133,0x01a0,0x0062,0x0140,0x0123,0x01a0,0x0061,0x0171,0x0143,0x0176,0x0122,0x0159,0x0171,0x0143,0x0180,0x01b1,
0x0000,0x01ca,0x0004,0x00f4,0x0000,0x0061,0x005e,0x005a,0x0175,0x0132,0x0171,0x0174,0x0150,0x0142,0x0176,0x0122,
0x0142,0x011d,0x00f3,0x0065,0x005e,0x005a,0x01c0,0x0003,0x00f5,0x0000,0x004c,0x004f,0x0047,0x005a,0x0150,0x0134,
0x0175,0x0181,0x014f,0x0150,0x0124,0x0195,0x0071,0x0195,0x0072,0x0175,0x0180,0x01b1,0x0000,0x01c4,0x0003,0x00f6,
0x0000,0x005a,0x005e,0x0031,0x002f,0x0057,0x0132,0x0175,0x0133,0x0175,0x0131,0x0151,0x0171,0x0130,0x0151,0x0140,
0x0120,0x0171,0x0143,0x0154,0x0176,0x0121,0x0171,0x0143,0x0123,0x0122,0x01c2,0x0004,0x00f4,0x0000,0x005a,0x005e,
0x0057,0x0181,0x014f,0x0150,0x014f,0x0175,0x0175,0x014f,0x0171,0x0175,0x0142,0x0175,0x0140,0x0174,0x014e,0x0155,
0x014e,0x0180,0x01b1,0x0000,0x01ca,0x0003,0x00f3,0x0000,0x0043,0x002b,0x0171,0x0106,0x0175,0x0140,0x0175,0x0140,
0x0174,0x01b1,0x0000,0x01c2,0x0002,0x00f3,0x0000,0x0043,0x002d,0x0154,0x0171,0x0154,0x01b6,0x0013,0x01c8,0x0001,
0x00f5,0x0000,0x0043,0x0049,0x004e,0x0056,0x01e0,0x0004,0x0082,0x01b1,0x0000,0x0103,0x014f,0x0160,0x0171,0x0154,
0x0171,0x014e,0x0185,0x01c0,0x0003,0x00f3,0x0000,0x0043,0x002a,0x014f,0x0175,0x0175,0x014f,0x0175,0x0175,0x0171,
0x0175,0x0142,0x0175,0x0140,0x0174,0x014e,0x01b1,0x0000,0x01c0,0x0003,0x00f3,0x0000,0x0043,0x002f,0x01e0,0x0024,
0x0002,0x011d,0x00f2,0x0043,0x002a,0x01cc,0x0001,0x0220,0x0010,0x0210,0x01c4,0x0001,0x00f5,0x0000,0x0053,0x0049,
0x004e,0x0048,0x0130,0x0158,0x0120,0x0155,0x0143,0x0120,0x0158,0x0140,0x0108,0x0112,0x0143,0x0185,0x01cc,0x0002,
0x00f5,0x0000,0x0043,0x004f,0x0053,0x0048,0x0155,0x0183,0x0160,0x0140,0x01b8,0x0012,0x01c0,0x0002,0x00f5,0x0000,
0x0054,0x0041,0x004e,0x0048,0x01a0,0x0061,0x0120,0x01a0,0x0062,0x0143,0x0185,0x01c2,0x0002,0x00f6,0x0000,0x0041,
0x0053,0x0049,0x004e,0x0048,0x0151,0x0176,0x0171,0x0111,0x0140,0x01b7,0x00a2,0x01c4,0x0002,0x00f6,0x0000,0x0041,
0x0054,0x0041,0x004e,0x0048,0x0111,0x0140,0x0183,0x0183,0x0112,0x0141,0x0143,0x0154,0x0150,0x01b8,0x0045,0x01cc,
0x0002,0x00f6,0x0000,0x0041,0x0043,0x004f,0x0053,0x0048,0x0151,0x0176,0x0171,0x0111,0x0141,0x0107,0x0152,0x0140,
0x0150,0x01c8,0x0002,0x0220,0x002d,0x0270,0x01c6,0x0000,0x00f4,0x0000,0x0053,0x0053,0x0053,0x01e0,0x0055,0x0086,
0x01f4,0x0053,0x0033,0x003d,0x003f,0x018e,0x0134,0x0106,0x0140,0x0140,0x0112,0x0143,0x0137,0x0151,0x0176,0x0122,
0x0142,0x0141,0x0120,0x0124,0x0142,0x0143,0x0152,0x015d,0x0112,0x0142,0x0135,0x0159,0x0120,0x0142,0x0136,0x0127,
0x0151,0x0176,0x0120,0x0142,0x0141,0x0122,0x0143,0x0124,0x0143,0x0152,0x015d,0x0112,0x0142,0x0133,0x0125,0x01e0,
0x0005,0x0080,0x0131,0x01b2,0x0000,0x0101,0x0140,0x015a,0x0154,0x015d,0x0185,0x01cc,0x0009,0x00f4,0x0000,0x0053,
0x0041,0x0041,0x01e0,0x0022,0x0087,0x01f4,0x0041,0x0032,0x003d,0x003f,0x018e,0x0133,0x0121,0x01e0,0x0019,0x0000,
0x0135,0x01b5,0x00b8,0x0107,0x01a8,0x0015,0x01f4,0x0053,0x0031,0x003d,0x003f,0x018e,0x0130,0x01f4,0x0053,0x0032,
0x003d,0x003f,0x018e,0x0132,0x0185,0x0108,0x01a8,0x0015,0x01f4,0x0053,0x0031,0x003d,0x003f,0x018e,0x0130,0x01f4,
0x0041,0x0031,0x003d,0x003f,0x018e,0x0131,0x0185,0x01c8,0x0008,0x00f4,0x0000,0x0041,0x0053,0x0041,0x01a8,0x0015,
0x01f4,0x0041,0x0033,0x003d,0x003f,0x018e,0x0135,0x01e0,0x0023,0x0007,0x0125,0x0105,0x0121,0x01e0,0x0059,0x0000,
0x0133,0x0125,0x0120,0x014e,0x0171,0x0136,0x0123,0x0111,0x014e,0x0175,0x0143,0x0132,0x0174,0x0142,0x0140,0x0134,
0x01b2,0x00d3,0x01c2,0x0006,0x00f4,0x0000,0x0053,0x0041,0x0053,0x01e0,0x0045,0x0007,0x01f4,0x0053,0x0032,0x003d,
0x003f,0x018e,0x0132,0x014e,0x0120,0x0141,0x014f,0x0134,0x0120,0x0122,0x0124,0x01b6,0x0000,0x01cc,0x0003,0x00f4,
0x0000,0x0053,0x0053,0x0041,0x01e0,0x0072,0x0006,0x01f4,0x0041,0x0032,0x003d,0x003f,0x018e,0x0133,0x0159,0x0122,
0x0142,0x0120,0x0143,0x015c,0x01e0,0x0013,0x0083,0x01e0,0x004d,0x0004,0x0120,0x0122,0x0146,0x01b3,0x0092,0x0125,
0x015a,0x0154,0x015d,0x01e0,0x0004,0x0083,0x01b5,0x005d,0x0104,0x0135,0x0123,0x01e0,0x00b7,0x0000,0x0131,0x0125,
0x0185,0x0103,0x0175,0x0175,0x0185,0x0102,0x01f3,0x0053,0x0031,0x003d,0x019b,0x0000,0x017e,0x01f3,0x0041,0x0031,
0x003d,0x019b,0x0001,0x017e,0x01f3,0x0053,0x0032,0x003d,0x019b,0x0002,0x017e,0x01f3,0x0041,0x0032,0x003d,0x019b,
0x0003,0x017e,0x01f3,0x0053,0x0033,0x003d,0x019b,0x0004,0x017e,0x01f3,0x0041,0x0033,0x003d,0x019b,0x0005,0x017e,
0x0126,0x0124,0x0142,0x0112,0x0143,0x01f5,0x0041,0x0052,0x0045,0x0041,0x003d,0x019b,0x0073,0x017e,0x01c2,0x0010,
0x0220,0x0032,0x0240,0x01cc,0x0000,0x00f6,0x0000,0x0054,0x0052,0x0041,0x004e,0x0053,0x0177,0x01a8,0x0015,0x01a8,
0x001b,0x0185,0x01cf,0x0066,0x0133,0x0177,0x01e0,0x001c,0x00fb,0x0129,0x0129,0x0111,0x0123,0x01cf,0x007c,0x01a9,
0x0000,0x0133,0x0174,0x0130,0x0174,0x0131,0x0174,0x0132,0x014f,0x0171,0x0175,0x014f,0x0195,0x0000,0x0195,0x0001,
0x0195,0x0002,0x0185,0x01cf,0x007b,0x01a9,0x0000,0x01a9,0x0001,0x01a9,0x0002,0x0139,0x0175,0x0138,0x0175,0x0137,
0x0185,0x01cf,0x0068,0x01a8,0x0002,0x0110,0x01cf,0x007d,0x01a9,0x0001,0x0129,0x0141,0x0191,0x0016,0x0177,0x0128,
0x0141,0x0191,0x0015,0x0177,0x0127,0x0141,0x0191,0x0014,0x01ac,0x0000,0x01b1,0x0083,0x01e0,0x0068,0x0085,0x0101,
0x018f,0x01a9,0x0000,0x0111,0x0011,0x013a,0x01e0,0x0028,0x0081,0x0134,0x0111,0x0012,0x013a,0x01e0,0x0021,0x0081,
0x0135,0x01ac,0x0002,0x0185,0x017f,0x0111,0x0013,0x013a,0x01e0,0x0016,0x0081,0x0136,0x0110,0x0124,0x0125,0x0126,
0x0185,0x01cf,0x007d,0x01a8,0x0000,0x01d0,0x0040,0x007d,0x01cf,0x0068,0x01a8,0x0000,0x01d0,0x004c,0x0068,0x0102,
0x0110,0x0190,0x0014,0x01e0,0x0027,0x0084,0x0190,0x0015,0x01e0,0x0022,0x0084,0x0190,0x0016,0x0111,0x0010,0x0193,
0x000a,0x0177,0x0190,0x008a,0x0191,0x0017,0x0175,0x0111,0x0010,0x0192,0x000a,0x0175,0x01e0,0x000e,0x0084,0x0190,
0x0017,0x0171,0x01ac,0x0001,0x0140,0x0198,0x0073,0x017f,0x0124,0x0171,0x0185,0x0105,0x0190,0x008a,0x0142,0x0140,
0x0113,0x0192,0x000a,0x0175,0x0185,0x0106,0x0123,0x0111,0x014e,0x0191,0x0017,0x0154,0x0171,0x0191,0x0018,0x0177,
0x0111,0x0140,0x0120,0x0121,0x0122,0x0174,0x013b,0x013c,0x013d,0x013e,0x013f,0x0191,0x0010,0x0191,0x0011,0x0191,
0x0012,0x0191,0x0013,0x0175,0x0194,0x0011,0x0194,0x0012,0x0194,0x0013,0x0194,0x0013,0x0194,0x0010,0x0194,0x000d,
0x0175,0x0194,0x000f,0x0194,0x000f,0x0194,0x000c,0x0194,0x0012,0x0194,0x000e,0x0194,0x0010,0x0175,0x0194,0x000c,
0x0194,0x000b,0x0194,0x000b,0x0194,0x000e,0x0194,0x0011,0x0194,0x000d,0x0175,0x0175,0x0190,0x0017,0x0192,0x000b,
0x0192,0x000f,0x0192,0x0013,0x0177,0x0190,0x0018,0x01ac,0x0001,0x0154,0x0142,0x0193,0x000c,0x0192,0x000e,0x0177,
0x0176,0x0142,0x0192,0x000d,0x0193,0x0011,0x0177,0x0176,0x0142,0x0192,0x0012,0x0193,0x0010,0x0185,0x01cf,0x006a,
0x01a8,0x0002,0x0110,0x01cf,0x007f,0x0191,0x0016,0x0175,0x0191,0x0015,0x0175,0x0191,0x0014,0x01a8,0x0001,0x01ac,
0x0000,0x01b7,0x0083,0x01e0,0x007f,0x0005,0x0107,0x01e0,0x00e9,0x0000,0x01a9,0x0001,0x0185,0x01cf,0x007f,0x01a8,
0x0000,0x01d0,0x001f,0x007f,0x01cf,0x006a,0x01a8,0x0000,0x01d0,0x002b,0x006a,0x01c2,0x0031,0x0220,0x0004,0x0260,
0x01c8,0x0000,0x00f4,0x0000,0x002a,0x0046,0x004e,0x01fe,0x0046,0x0055,0x004e,0x0043,0x0054,0x0049,0x004f,0x004e,
0x0020,0x004e,0x0041,0x004d,0x0045,0x003f,0x018c,0x018e,0x01c6,0x0003,0x0220,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0004,0x0031,0x000d,0x002d,0x00a4,

// HP41C_EMBEDDED_CODE_END
};

////////////////////////////////////////////////////////////////////////////////

/*
 * i2c_functions.c
 *
 *  Created on: 23 Jul 2016
 *      Author: menadue
 */
//#include "chip.h"
//#include "board.h"
//#include "i2c_functions.h"


// I2C functions

// Release the bus
void i2c_release(I2C_PORT_DESC *port) {
  // All inputs
  gpio_set_dir(SDA_PIN,GPIO_OUT);
  gpio_set_dir(SCL_PIN,GPIO_OUT);
  gpio_put(SDA_PIN, 0);
  gpio_put(SCL_PIN, 0);
  
  //  Chip_GPIO_SetPinDIRInput(LPC_GPIO, port->sdaport, port->sdabit);
  //Chip_GPIO_SetPinDIRInput(LPC_GPIO, port->sclport, port->sclbit);
}

// Delay to slow down to I2C bus rates
void i2c_delay(I2C_PORT_DESC *port) {
  sleep_us(1);
  return;
  volatile int i;
  for(i=0; i<1; i++)
    {
    }
  
}

void i2c_sda_low(I2C_PORT_DESC *port)
{
  // Take SCL low by driving a 0 on to the bus
  gpio_set_dir(SDA_PIN,GPIO_OUT);
  gpio_put(SDA_PIN, 0);
  //Chip_GPIO_SetPinState(LPC_GPIO, port->sdaport, port->sdabit, 0);
  
  // Make sure bit is an output
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, port->sdaport, port->sdabit);
}

void i2c_sda_high(I2C_PORT_DESC *port)
{
  // Make sure bit is an input
  gpio_set_dir(SDA_PIN,GPIO_IN);
  //  gpio_put(SDA_PIN, 1);
  //  Chip_GPIO_SetPinDIRInput(LPC_GPIO, port->sdaport, port->sdabit);
}

void i2c_scl_low(I2C_PORT_DESC *port) {

  gpio_set_dir(SCL_PIN,GPIO_OUT);
  gpio_put(SCL_PIN, 0);
  
  //  Chip_GPIO_SetPinState(LPC_GPIO, port->sclport, port->sclbit, 0);

  // Make sure bit is an output
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, port->sclport, port->sclbit);
}

void i2c_scl_high(I2C_PORT_DESC *port)
{
  // Make sure bit is an input
  gpio_set_dir(SCL_PIN, GPIO_IN);
  //gpio_put(SCL_PIN, 1);
  //Chip_GPIO_SetPinDIRInput(LPC_GPIO, port->sclport, port->sclbit);
}

// Read ACK bit

int i2c_read_sda(I2C_PORT_DESC *port)
{
  return(gpio_get(SDA_PIN));
  //  return(Chip_GPIO_GetPinState(LPC_GPIO, port->sdaport, port->sdabit));

  //  return( ((*(port->port)) & (port->sda_mask)) == port->sda_mask);
}

// I2C start condition

void i2c_start(I2C_PORT_DESC *port)
{
  //
  i2c_sda_low(port);

  i2c_delay(port);
  i2c_scl_low(port);
  i2c_delay(port);
}

void i2c_stop(I2C_PORT_DESC *port)
{
  i2c_scl_high(port);
  i2c_delay(port);
  i2c_sda_high(port);
  i2c_delay(port);

}

// Send 8 bits and read ACK
// Returns number of acks received

int i2c_send_byte(I2C_PORT_DESC *port, BYTE b)
{
  int i;
  int ack=0;
  int retries = 100;
  int rc =1;

  for (i = 0; i < 8; i++)
    {
      // Set up data
      if ((b & 0x80) == 0x80)
	{
	  i2c_sda_high(port);
	} else
	{
	  i2c_sda_low(port);
	}

      // Delay
      i2c_delay(port);

      // Take clock high and then low
      i2c_scl_high(port);

      // Delay
      i2c_delay(port);

      // clock low again
      i2c_scl_low(port);

      // Delay
      i2c_delay(port);

      // Shift next data bit in
      b <<= 1;
    }

  // release data line
  i2c_sda_high(port);

  // Now get ACK
  i2c_scl_high(port);

  i2c_delay(port);

  // read ACK

  while( ack = i2c_read_sda(port) ) // @suppress("Assignment in condition")
    {
      retries--;

      if ( retries == 0 )
	{
	  rc = 0;
	  break;
	}
    }

  i2c_scl_low(port);

  i2c_delay(port);
  return (rc);
}


// Receive 8 bits and set ACK
// Ack as specified
void i2c_recv_byte(I2C_PORT_DESC *port, BYTE *data, int ack)
{
  int i, b;

  b = 0;

  // Make data an input
  i2c_sda_high(port);

  for (i = 0; i < 8; i++)
    {
      // Delay
      i2c_delay(port);

      // Take clock high and then low
      i2c_scl_high(port);

      // Delay
      i2c_delay(port);

      // Shift next data bit in
      b <<= 1;
      b += (i2c_read_sda(port) & 0x1);

      // clock low again
      i2c_scl_low(port);

      // Delay
      i2c_delay(port);

    }

  // ACK is as we are told 
  if ( ack )
    {
      // Data low for ACK
      i2c_sda_low(port);
    }
  else
    {
      i2c_sda_high(port);
    }

  // Now send ACK
  i2c_scl_high(port);

  i2c_delay(port);

  i2c_scl_low(port);

  i2c_delay(port);

  *data = b;

}

// Reads a block of bytes from a slave

int i2c_read_bytes(I2C_SLAVE_DESC *slave, int n, BYTE *data)
{
  int i;
  BYTE byte;

  i2c_start(slave->port);

  // Send slave address with read bit
  if ( !i2c_send_byte(slave->port, ((slave->slave_7bit_addr) << 1) | 1) )
    {
      i2c_stop(slave->port);
      return(0);
    }


  //
  for (i = 0; i < n; i++)
    {
      i2c_recv_byte(slave->port, &byte, (i==(n-1))? 0 : 1);
      *(data++) = byte;
    }

  i2c_stop(slave->port);

  return(1);
}

// Sends a block of data to I2C slave
void i2c_send_bytes(I2C_SLAVE_DESC *slave, int n, BYTE *data)
{
  int i;

  i2c_start(slave->port);

  // Send slave address with read bit
  i2c_send_byte(slave->port, ((slave->slave_7bit_addr) << 1) | 0);

  //
  for (i = 0; i < n; i++)
    {
      i2c_send_byte(slave->port, *(data++));
    }

  i2c_stop(slave->port);
}

void i2c_init(I2C_PORT_DESC *port)
{
  gpio_init(SDA_PIN);
  gpio_init(SCL_PIN);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 0, 19);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 0, 2);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 0, 18);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 0, 7);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 1, 19);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 1, 20);
}

/*
 * oled096.h
 *
 *  Created on: 23 Jul 2016
 *      Author: menadue
 */

#ifndef OLED096_H_
#define OLED096_H_

#define I2C_CMD       1
#define I2C_DATA      0
#define I2C_REPEAT    1
#define I2C_NO_REPEAT 0

void oled_send_cmd(I2C_SLAVE_DESC *slave, int n, unsigned char *data, int command, int repeat);
void oled_set_xy(I2C_SLAVE_DESC *slave, int x, int y);
void oled_set_pixel_xy(I2C_SLAVE_DESC *slave, int x, int y);
void oled_set_byte_xy(I2C_SLAVE_DESC *slave, int x, int y, int b);
void oled_gap(I2C_SLAVE_DESC *slave);
void oled_display_int(I2C_SLAVE_DESC *slave, long int n, int num_digits);
void oled_display_string(I2C_SLAVE_DESC *slave, char *string);
void oled_clear_display(I2C_SLAVE_DESC *slave);

void oled_setup(I2C_SLAVE_DESC *slave);
void oled_display_scaled_string_xy(I2C_SLAVE_DESC *slave, char *string, int x, int y, int scale);

extern unsigned char font_5x7_letters[];

#endif /* OLED096_H_ */

/*
 * oled096.c
 *
 *  Created on: 23 Jul 2016
 *      Author: menadue
 */

//
// 0.96" OLED display functions
//


// Sends a block of commands to the SSD1306
// command causes 80 to be sent before each byte
// command = 0 causes 0x40 and just data bytes
// Repeat = 1, repeat data byte 0

//#include <string.h>
//#include "i2c_functions.h"
//#include "oled096.h"

void oled_send_cmd(I2C_SLAVE_DESC *slave, int n, unsigned char *data, int command, int repeat)
{
  int i;

  i2c_start(slave->port);

  // Send slave address
  i2c_send_byte(slave->port, (slave->slave_7bit_addr)<<1);

  if ( !command )
    {
      i2c_send_byte(slave->port, 0x40);
    }

  // Send the command bytes, each preceded bu 0x80 (continuation)
  for (i = 0; i < n; i++) {
    if ( command )
      {
        i2c_send_byte(slave->port, 0x80);
      }
    i2c_send_byte(slave->port, *data);

    if ( !repeat )
      {
	data++;
      }
  }

  i2c_stop(slave->port);
}

//--------------------------------------------------------------------------------
// OLED display functions
//

unsigned char init_seq[] = {
				  0xae,                       // ???
				  0xd5, 0x80,

				  0xa8,0x3f,

				  0xd3,0x00,
				  0x8d,0x14,0x40,0xa6,0xa4,0xa1,0xc8,0xda,0x12,0x81,0x8f,
				  0xd9,         //??

				  0xf1,0xdb,0x40,0xaf,
};

// From data sheet
unsigned char init_seq2[] = {
				   //  0xae,          // Display Off
#if PICOPAK
				   0xa8,0x1f,       // MUX ratio works for now
#else
				   0xa8,0x3f,       // MUX ratio works for now
#endif
				   0xd3,0x00,       // Set display offset 0
				   0x40,            // Set display start Line
				   0x8d,0x14,       // Charge pump ON, needed or blank display
				   0xa1,            // Seg remap 180 rotate
				   0xc8,            // Inverted COM scan
#if PICOPAK				   
				   0xda, 0x02,      // COM config: A5:Disable left/right remap, A4:Alternate COM pin config from 12
#else
				   0xda, 0x12,      // COM config: A5:Disable left/right remap, A4:Alternate COM pin config from 12
#endif
				   0x81,0x2f,      // Contrast value
				   //				   0x81,0x2f,      // Contrast value
				   0xd9, 0xf1,     // Precharge, quite important
				   0xdb, 0x40,     // Set Vcomh level, leave it out and inverted display.

				   0xa6,            // Normal display (not inverted)
				   0xd5,0x80,       // Set display oscillator

				   0x20, 0x02,        // Page addressing mode
				   0x21,0x00,0x7f,               // Set display RAM start and end address
				   // seems to have effect in page addressing mode.
				   0x22,0x00,0x07,               // Set display page address

				   0xa4,
				   0xaf,             // Display ON
};

unsigned char display_setup_seq[] = {
					   0x21,0x00,0x7f,               // Set display RAM start and end address
					   0x22,0x00,0x3f,               // Set display page address
};


unsigned char display_text_seq[] = {
					  0x7e,0x11,0x11,0x11,0x7e,0x00,0x7f,0x49,0x49,0x49,0x36,0x00,0x00,0x3e,0x41,0x41,0x41,0x22,0x00,0x7f,0x41,0x41,0x41,0x22,0x1c,0x00,0x7f,0x49,0x49,0x49,0x41,0x00,
};

void oled_set_brightness(I2C_SLAVE_DESC *slave, int percent)
{
  unsigned char seq[2];

  seq[0] = 0x81;      // Set contrast (brightness)
  seq[1] = percent * 255 / 100;

  oled_send_cmd(slave, sizeof(seq), &(seq[0]), I2C_CMD, I2C_NO_REPEAT);
}

// Set XY to given position
// We attempt to position to the byte that holds the pixel (x,y)
// Page addressing mode

void oled_set_xy(I2C_SLAVE_DESC *slave, int x, int y)
{
  unsigned char seq[3];

  x = x % 128;
  y = y % 64;
  seq[0] = 0xB0+y/8;      // Set page
  seq[1] = 0x00+x%16;     // Set low part of start address
  seq[2] = 0x10+x/16;     // Set high part

  oled_send_cmd(slave, sizeof(seq), &(seq[0]), I2C_CMD, I2C_NO_REPEAT);
}

unsigned char byteval[1];

// Writes bit pattern at x,y
void oled_set_pixel_xy(I2C_SLAVE_DESC *slave, int x, int y)

{
  byteval[0] = 1<< (y % 8);

  oled_set_xy(slave, x, y);
  oled_send_cmd(slave, 1, &(byteval[0]), I2C_DATA, I2C_NO_REPEAT);
}
void i2c_send_bytes(I2C_SLAVE_DESC *slave, int n, BYTE *data);
#

I2C_PORT_DESC i2c_bus_0 =
  {
   0, 18,
   0, 7,
  };

// Dummy structure
I2C_SLAVE_DESC oled0 =
  {
   &i2c_bus_0,
   0x78 >>1,
  };


void oled_set_byte_xy(I2C_SLAVE_DESC *slave, int x, int y, int b)
{
  byteval[0] = b;

  oled_set_xy(slave, x, y);
  oled_send_cmd(slave, 1, &(byteval[0]), I2C_DATA, I2C_NO_REPEAT);
}


// Font

unsigned char font_5x7_letters[] = {
					  0x00, 0x00, 0x00, 0x00, 0x00,// (space)
					  0x00, 0x00, 0x5F, 0x00, 0x00,// !
					  0x00, 0x07, 0x00, 0x07, 0x00,// "
					  0x14, 0x7F, 0x14, 0x7F, 0x14,// #
					  0x24, 0x2A, 0x7F, 0x2A, 0x12,// $
					  0x23, 0x13, 0x08, 0x64, 0x62,// %
					  0x36, 0x49, 0x55, 0x22, 0x50,// &
					  0x00, 0x05, 0x03, 0x00, 0x00,// '
					  0x00, 0x1C, 0x22, 0x41, 0x00,// (
					  0x00, 0x41, 0x22, 0x1C, 0x00,// )
					  0x08, 0x2A, 0x1C, 0x2A, 0x08,// *
					  0x08, 0x08, 0x3E, 0x08, 0x08,// +
					  0x00, 0x50, 0x30, 0x00, 0x00,// ,
					  0x08, 0x08, 0x08, 0x08, 0x08,// -
					  0x00, 0x60, 0x60, 0x00, 0x00,// .
					  0x20, 0x10, 0x08, 0x04, 0x02,// /
					  0x3E, 0x51, 0x49, 0x45, 0x3E,// 0
					  0x00, 0x42, 0x7F, 0x40, 0x00,// 1
					  0x42, 0x61, 0x51, 0x49, 0x46,// 2
					  0x21, 0x41, 0x45, 0x4B, 0x31,// 3
					  0x18, 0x14, 0x12, 0x7F, 0x10,// 4
					  0x27, 0x45, 0x45, 0x45, 0x39,// 5
					  0x3C, 0x4A, 0x49, 0x49, 0x30,// 6
					  0x01, 0x71, 0x09, 0x05, 0x03,// 7
					  0x36, 0x49, 0x49, 0x49, 0x36,// 8
					  0x06, 0x49, 0x49, 0x29, 0x1E,// 9
					  0x00, 0x36, 0x36, 0x00, 0x00,// :
					  0x00, 0x56, 0x36, 0x00, 0x00,// ;
					  0x00, 0x08, 0x14, 0x22, 0x41,// <
					  0x14, 0x14, 0x14, 0x14, 0x14,// =
					  0x41, 0x22, 0x14, 0x08, 0x00,// >
					  0x02, 0x01, 0x51, 0x09, 0x06,// ?
					  0x32, 0x49, 0x79, 0x41, 0x3E,// @
					  0x7E, 0x11, 0x11, 0x11, 0x7E,// A
					  0x7F, 0x49, 0x49, 0x49, 0x36,// B
					  0x3E, 0x41, 0x41, 0x41, 0x22,// C
					  0x7F, 0x41, 0x41, 0x22, 0x1C,// D
					  0x7F, 0x49, 0x49, 0x49, 0x41,// E
					  0x7F, 0x09, 0x09, 0x01, 0x01,// F
					  0x3E, 0x41, 0x41, 0x51, 0x32,// G
					  0x7F, 0x08, 0x08, 0x08, 0x7F,// H
					  0x00, 0x41, 0x7F, 0x41, 0x00,// I
					  0x20, 0x40, 0x41, 0x3F, 0x01,// J
					  0x7F, 0x08, 0x14, 0x22, 0x41,// K
					  0x7F, 0x40, 0x40, 0x40, 0x40,// L
					  0x7F, 0x02, 0x04, 0x02, 0x7F,// M
					  0x7F, 0x04, 0x08, 0x10, 0x7F,// N
					  0x3E, 0x41, 0x41, 0x41, 0x3E,// O
					  0x7F, 0x09, 0x09, 0x09, 0x06,// P
					  0x3E, 0x41, 0x51, 0x21, 0x5E,// Q
					  0x7F, 0x09, 0x19, 0x29, 0x46,// R
					  0x46, 0x49, 0x49, 0x49, 0x31,// S
					  0x01, 0x01, 0x7F, 0x01, 0x01,// T
					  0x3F, 0x40, 0x40, 0x40, 0x3F,// U
					  0x1F, 0x20, 0x40, 0x20, 0x1F,// V
					  0x7F, 0x20, 0x18, 0x20, 0x7F,// W
					  0x63, 0x14, 0x08, 0x14, 0x63,// X
					  0x03, 0x04, 0x78, 0x04, 0x03,// Y
					  0x61, 0x51, 0x49, 0x45, 0x43,// Z
					  0x00, 0x00, 0x7F, 0x41, 0x41,// [
					  0x02, 0x04, 0x08, 0x10, 0x20,// "\"
					  0x41, 0x41, 0x7F, 0x00, 0x00,// ]
					  0x04, 0x02, 0x01, 0x02, 0x04,// ^
					  0x40, 0x40, 0x40, 0x40, 0x40,// _
					  0x00, 0x01, 0x02, 0x04, 0x00,// `
					  0x20, 0x54, 0x54, 0x54, 0x78,// a
					  0x7F, 0x48, 0x44, 0x44, 0x38,// b
					  0x38, 0x44, 0x44, 0x44, 0x20,// c
					  0x38, 0x44, 0x44, 0x48, 0x7F,// d
					  0x38, 0x54, 0x54, 0x54, 0x18,// e
					  0x08, 0x7E, 0x09, 0x01, 0x02,// f
					  0x08, 0x14, 0x54, 0x54, 0x3C,// g
					  0x7F, 0x08, 0x04, 0x04, 0x78,// h
					  0x00, 0x44, 0x7D, 0x40, 0x00,// i
					  0x20, 0x40, 0x44, 0x3D, 0x00,// j
					  0x00, 0x7F, 0x10, 0x28, 0x44,// k
					  0x00, 0x41, 0x7F, 0x40, 0x00,// l
					  0x7C, 0x04, 0x18, 0x04, 0x78,// m
					  0x7C, 0x08, 0x04, 0x04, 0x78,// n
					  0x38, 0x44, 0x44, 0x44, 0x38,// o
					  0x7C, 0x14, 0x14, 0x14, 0x08,// p
					  0x08, 0x14, 0x14, 0x18, 0x7C,// q
					  0x7C, 0x08, 0x04, 0x04, 0x08,// r
					  0x48, 0x54, 0x54, 0x54, 0x20,// s
					  0x04, 0x3F, 0x44, 0x40, 0x20,// t
					  0x3C, 0x40, 0x40, 0x20, 0x7C,// u
					  0x1C, 0x20, 0x40, 0x20, 0x1C,// v
					  0x3C, 0x40, 0x30, 0x40, 0x3C,// w
					  0x44, 0x28, 0x10, 0x28, 0x44,// x
					  0x0C, 0x50, 0x50, 0x50, 0x3C,// y
					  0x44, 0x64, 0x54, 0x4C, 0x44,// z
					  0x00, 0x08, 0x36, 0x41, 0x00,// {
					  0x00, 0x00, 0x7F, 0x00, 0x00,// |
					  0x00, 0x41, 0x36, 0x08, 0x00,// }
					  0x08, 0x08, 0x2A, 0x1C, 0x08,// ->
					  0x08, 0x1C, 0x2A, 0x08, 0x08 // <-
};

// Turn display off
unsigned char off_seq = {
			       0xae
};

// Turn display on
unsigned char on_seq = {
			      0xaf
};


// Prints a character gap
void oled_gap(I2C_SLAVE_DESC *slave)
{
  unsigned char zero = 0;

  oled_send_cmd(slave, 1, &zero, I2C_DATA, I2C_NO_REPEAT);
}

// Displays an integer in decimal, number of digits displayed is specified, MS digits dropped

void oled_display_int(I2C_SLAVE_DESC *slave, long int n, int num_digits)
{
  int i;
  int dig;
  int mul = 10000;

  if( n < 0 )
    {
      oled_display_string(slave, "-");
      n = -n;
    }
  else
    {
      oled_display_string(slave, " ");
    }

  for(i=5; i>0; i--)
    {
      dig = n / mul;
      n = n % mul;
      mul /=10;

      // Display digit
      if ( i <= num_digits )
	{
	  oled_send_cmd(slave, 5, font_5x7_letters+('0'-' ')*5+dig*5, I2C_DATA, I2C_NO_REPEAT);
	  oled_gap(slave);
	}
    }
}

void oled_display_string(I2C_SLAVE_DESC *slave, char *string)
{
  int j;
  int len = strlen(string);

  for(j=0; j<len; j++)
    {
      oled_send_cmd(slave, 5, font_5x7_letters+((*string++) - ' ')*5, I2C_DATA, I2C_NO_REPEAT);
      oled_gap(slave);
    }
}

BYTE zero = 0;
void oled_clear_display(I2C_SLAVE_DESC *slave)
{
  int y;

  for(y=0; y<64; y+=8)
    {
      oled_set_xy(slave, 0, y);
      oled_send_cmd(slave, 128, &zero, I2C_DATA, I2C_REPEAT);
    }

}

//
// Displays a string with pixel scaling
//
unsigned char scaled_line[100];

void oled_display_scaled_string_xy(I2C_SLAVE_DESC *slave, char *string, int x, int y, int scale)
{
  unsigned char i;
  int  j, k, s;
  int scale_i;
  int len = strlen(string);
  int b;

  // We now display the string a character at a time, each character being scaled
  scale_i = 0;

  for(k=0; k<len; k++)
    {
      // Scale character
      // We start with 5 bytes, each of 8 bits, these are vertical slices of the bit pattern
      // We need to stretch the character vertically by scale

      for(i=0; i<5; i++)
	{
	  // For each byte we build a new bitmap that is scaled
	  for(j=0; j<8; j++)
	    {
	      // Get next bit
	      b  = (*(font_5x7_letters+((*string)-' ')*5+i));
	      b &= (1 << (7-j));
	      b >>= (7-j);

	      // Shift more bits in to scaled data
	      for(s=0; s<scale;s++)
		{
		  scaled_line[scale_i/8] <<= 1;
		  scaled_line[scale_i/8] |= b;
		  scale_i++;
		}
	    }
#if 0
	  // Move to next byte
	  while( (scale_i % 8) != 0 )
	    {
	      scale_i++;
	    }
#endif
	}

      // Put a gap between chars
      for(s=0; s<scale;s++)
	{
	  scaled_line[scale_i/8] = 0;
	  scale_i+=8;
	}

      string++;
    }

  // Send scaled data to display
  for(j=0; j < scale; j++)
    {
      oled_set_xy(slave, x, y+8*((scale-1)-j));
      for(i=0; i<5*len*scale; i+=scale)
	{
	  for(s=0; s<scale;s++)
	    {
	      oled_send_cmd(slave, 1, &(scaled_line[i+j]), I2C_DATA, I2C_NO_REPEAT);
	    }
	}
      oled_gap(slave);
    }

#if 0
  oled_set_xy(slave, 0,0);
  for(j=0;j<scale_i/8;j++)
    {
      oled_send_cmd(slave, 1, &(scaled_line[j]), I2C_DATA, I2C_NO_REPEAT);
    }


  oled_set_xy(slave, 30, 24);
  oled_display_int(slave, scale_i,5);
  oled_set_xy(slave, 30, 32);
  oled_display_int(slave, len,5);
#endif
}

void oled_error(char *str)
{
  oled_clear_display(&oled0);
  
  oled_set_xy(&oled0, 0,0);
  oled_display_string(&oled0, str);
  sleep_ms(3000);
}

void oled_setup(I2C_SLAVE_DESC *slave)
{
  int i;

  // Release bus
  i2c_release(slave->port);

  // Delay to allow things to start up.
  for(i=0; i<10000; i++)
    {
    }

  // Then clear any glitched I2C commands with a start and stop
  i2c_start(slave->port);
  i2c_stop(slave->port);

  // Initialise display
  oled_send_cmd(slave, sizeof(init_seq2), &(init_seq2[0]), 1, 0);

  // Clear display
  oled_clear_display(slave);


}

////////////////////////////////////////////////////////////////////////////////
//
// keyboard
//
////////////////////////////////////////////////////////////////////////////////

// NOTE: Control lines for MUX chips are inverted by level shifter

void kb_all_off(void)
{
#if 0
  while(1)
    {
      // All switches off
      gpio_put(P_KB_INH, 0);
      sleep_us(1);
      gpio_put(P_KB_INH, 1);
      sleep_us(1);
    }
#endif
        gpio_put(P_KB_INH, 1);
}




void kb_init()
{
  gpio_init(P_KB_INH);
  gpio_init(P_KRA);
  gpio_init(P_KRB);
  gpio_init(P_KRC);
  gpio_init(P_KCA);
  gpio_init(P_KCB);
  gpio_init(P_KCC);

#if 1
  gpio_set_dir(P_KB_INH, GPIO_OUT);
  gpio_set_dir(P_KRA, GPIO_OUT);
  gpio_set_dir(P_KRB, GPIO_OUT);
  gpio_set_dir(P_KRC, GPIO_OUT);
  gpio_set_dir(P_KCA, GPIO_OUT);
  gpio_set_dir(P_KCB, GPIO_OUT);
  gpio_set_dir(P_KCC, GPIO_OUT);
#endif
  
  kb_all_off();
}

////////////////////////////////////////////////////////////////////////////////

void drv_init(void)
{
  const uint P_FI_OE             = 17;
const uint P_SYNC_OE           = 18;
const uint P_ISA_OE            = 19;
const uint P_DATA_OE           = 20;

  gpio_init(P_FI_OE);
  gpio_init(P_SYNC_OE);
  gpio_init(P_ISA_OE);
  gpio_init(P_DATA_OE);

  gpio_set_dir(P_FI_OE, GPIO_OUT);
  gpio_set_dir(P_SYNC_OE, GPIO_OUT);
  gpio_set_dir(P_ISA_OE, GPIO_OUT);
  gpio_set_dir(P_DATA_OE, GPIO_OUT);

  gpio_put(P_FI_OE, 1);
  gpio_put(P_SYNC_OE, 1);
  gpio_put(P_ISA_OE, 1);
  gpio_put(P_DATA_OE, 1);

  gpio_init(P_ISA_DRV);
  gpio_set_dir(P_ISA_DRV, GPIO_OUT);
  gpio_put(P_ISA_DRV, 0);
}

////////////////////////////////////////////////////////////////////////////////
//
// Bus
//
////////////////////////////////////////////////////////////////////////////////

void bus_init(void)
{
  gpio_init(P_CLK1);
  gpio_set_dir(P_CLK1, GPIO_IN);
  gpio_init(P_CLK2);
  gpio_set_dir(P_CLK2, GPIO_IN);
  gpio_init(P_SYNC);
  gpio_set_dir(P_SYNC, GPIO_IN);
  gpio_init(P_ISA);
  gpio_set_dir(P_ISA, GPIO_IN);
  gpio_init(P_DATA);
  gpio_set_dir(P_DATA, GPIO_IN);
  
}

////////////////////////////////////////////////////////////////////////////////

#define NUM_FRAG 100


int fclk1[NUM_FRAG];
int fclk2[NUM_FRAG];
int fsync[NUM_FRAG];
int fisa[NUM_FRAG];
int fdata[NUM_FRAG];
int fcycno[NUM_FRAG];

////////////////////////////////////////////////////////////////////////////////
//
// Grab some bus cycles

void display_bus_cycles(void)
{
  int sync;
  int last_sync;
  int cycle_no = 0;
  
  // Wait for falling edge of sync, that is the start of a cycle
  
  last_sync = gpio_get(P_SYNC);
  
  while(1)
    {
      sync = gpio_get(P_SYNC);
      if( (last_sync==1) && (sync==0) )
	{
	  // Start of cycle
	  cycle_no = 0;
	}
      last_sync = sync;
      
      // Check the clocks and clock data in
      
    }
  
  for(int i=0; i<NUM_FRAG; i++)
    {
      fclk1[i] = gpio_get(P_CLK1);
      fclk2[i] = gpio_get(P_CLK2);
      fsync[i] = gpio_get(P_SYNC);
      fisa[i] =  gpio_get(P_ISA);
      fdata[i] = gpio_get(P_DATA);
    }
  
  // Display on USB
  for(int i=0; i<NUM_FRAG; i++)
    {
      printf("\n%04X: clk1=%d clk2=%d sync=%d isa=%d data=%d", i, fclk1[i], fclk2[i], fsync[i], fisa[i], fdata[i]);
    }
  printf("\n");
}

////////////////////////////////////////////////////////////////////////////////
// Quickly grab the bus and store it then dump to USB


void display_bus_fragment(void)
{
  int last_sync;
  int last_clk1;

  irq_set_mask_enabled(0xffffffff, false);
    
  last_sync = gpio_get(P_SYNC);
  last_clk1 = gpio_get(P_CLK1);
  
  for(int i=0; i<NUM_FRAG; i++)
    {
      fclk1[i] = gpio_get(P_CLK1);
      fclk2[i] = gpio_get(P_CLK2);
      fsync[i] = gpio_get(P_SYNC);
      fisa[i] =  gpio_get(P_ISA);
      fdata[i] = gpio_get(P_DATA);


      // If clk1 has a low edge then count it
      if( (last_clk1==1) && (fclk1[i]==0) )
	{
	  if( i == 0 )
	    {
	      fcycno[i] == 0;
	    }
	  else
	    {
	      fcycno[i] = fcycno[i-1]+1;
	    }
	}
      else
	{
	  if( i == 0 )
	    {
	      fcycno[i] == 0;
	    }
	  else
	    {
	      fcycno[i] = fcycno[i-1];
	    }
	}

      if( (last_sync==1) && (fsync[i]==0) )
	{
	  // Start of cycle
	  fcycno[i] = 0;
	}

      last_clk1 = fclk1[i];
      last_sync = fsync[i];
    }

  irq_set_mask_enabled(0xffffffff, true);
    
  // Display on USB
  for(int i=0; i<NUM_FRAG; i++)
    {
      printf("\n%04X: clk1=%d clk2=%d sync=%d isa=%d data=%d cyc=%02d", i, fclk1[i], fclk2[i], fsync[i], fisa[i], fdata[i], fcycno[i]);
    }
  printf("\n");
}

void display_captured_bus_fragment(void)
{
  // Display on USB
  for(int i=0; i<NUM_FRAG; i++)
    {
      printf("\n%04X: clk1=%d clk2=%d sync=%d isa=%d data=%d cyc=%02d", i, fclk1[i], fclk2[i], fsync[i], fisa[i], fdata[i], fcycno[i]);
    }
  printf("\n");
}



void capture_bus_fragment(void)
{
  int last_sync;
  int last_clk1;

  last_sync = gpio_get(P_SYNC);
  last_clk1 = gpio_get(P_CLK1);
  
  for(int i=0; i<NUM_FRAG; i++)
    {
      fclk1[i] = gpio_get(P_CLK1);
      fclk2[i] = gpio_get(P_CLK2);
      fsync[i] = gpio_get(P_SYNC);
      fisa[i] =  gpio_get(P_ISA);
      fdata[i] = gpio_get(P_DATA);


      // If clk1 has a low edge then count it
      if( (last_clk1==1) && (fclk1[i]==0) )
	{
	  if( i == 0 )
	    {
	      fcycno[i] == 0;
	    }
	  else
	    {
	      fcycno[i] = fcycno[i-1]+1;
	    }
	}
      else
	{
	  if( i == 0 )
	    {
	      fcycno[i] == 0;
	    }
	  else
	    {
	      fcycno[i] = fcycno[i-1];
	    }
	}

      if( (fclk1[i]== 1) && (last_sync==1) && (fsync[i]==0) )
	{
	  // Start of cycle
	  fcycno[i] = 44;
	}

      last_clk1 = fclk1[i];
      last_sync = fsync[i];
    }
}


void display_bus_states(void)
{
  int clk1, clk2, sync, isa, data;
  
  clk1 = gpio_get(P_CLK1);
  clk2 = gpio_get(P_CLK2);
  sync = gpio_get(P_SYNC);
  isa =  gpio_get(P_ISA);
  data = gpio_get(P_DATA);

  printf("\nclk1=%d clk2=%d sync=%d isa=%d data=%d\n", clk1, clk2, sync, isa, data);
}

#define NUM_TRANS      100
int trans_addr[NUM_TRANS];
int trans_data[NUM_TRANS];
int trans_instruction[NUM_TRANS];
int trans_pa[NUM_TRANS];
uint64_t trans_data56[NUM_TRANS];

#define TDB 0

void capture_bus_transactions(void)
{
  int last_sync   = 0;
  int trans_i     = 0;
  int data        = 0;
  int periph_addr = 0;
  int instruction = 0;
  int bit_no      = 0;
  int gpio_states = 0;
  int sync        = 0;
  int address     = 0;
  int  data56      = 0;
  
  gpio_states = sio_hw->gpio_in;
  last_sync = gpio_states & (1<<P_SYNC);  

  while(1)
    {
      // Wait for CLK1 to have a falling edge
      // Wait while low
      while( ((gpio_states = sio_hw->gpio_in) & (1 << P_CLK1)) == 0 )
	{
	}

      // Now high, wait for falling edge
      while( ((gpio_states = sio_hw->gpio_in) & (1 << P_CLK1)) != 0 )
	{
	}

      // Another bit, check SYNC to find bit number
      sync = gpio_states & (1<<P_SYNC);

      if( (last_sync == 0) && (sync != 0) )
	{
#if TDB	  
	  printf("\n44");
#endif
	  bit_no = 44;
	}
      else
	{
	  bit_no = (bit_no + 1) % 56;
#if TDB	  
	  printf("\n%d %08X", bit_no, gpio_states);
#endif
	}
      
      // Get data and put into data or instruction if bit no is OK for those fields
      if( (bit_no >= 44) && (bit_no <= 53) )
	{
	  instruction |= ((gpio_states & (1<<P_ISA))>>(P_ISA)) << ((bit_no - 44));
#if TDB	  
	  printf("\nI=%d (%08X)", instruction, gpio_states & (1<<P_ISA));
#endif

	}
      
      if( (bit_no >= 14) && (bit_no <= 29) )
	{
	  address |= ((gpio_states & (1<<P_ISA))>>(P_ISA)) << ((bit_no - 14));
#if TDB
	  printf("\nA=%d (%08X)", address, gpio_states & (1<<P_ISA));
#endif

	}

      if( (bit_no >= 0) && (bit_no <= 7) )
	{
	  periph_addr |= ((gpio_states & (1<<P_DATA))>>(P_DATA)) << ((bit_no - 0));
	}

      if( (bit_no >= 0) && (bit_no <= 55) )
	{
	  data56 |= ((gpio_states & (1<<P_DATA))>>(P_DATA)) << ((bit_no - 0));
	}
      
      // If bitno = 55 then we have another frame, store the transaction
      if( bit_no == 55 )
	{
	  trans_addr[trans_i]        = address;
	  trans_instruction[trans_i] = instruction;
	  trans_pa[trans_i]          = periph_addr;
	  trans_data56[trans_i]      = data56;
	  
	  address      = 0;
	  instruction  = 0;
	  data56       = 0;
	  periph_addr  = 0;
	  trans_i++;
	}
      
      if( trans_i == NUM_TRANS )
	{
	  // All done, exit
	  break;
	}
      
      last_sync = sync;
    }

  // Display what we captured
  for( int i=0; i<NUM_TRANS; i++)
    {
      printf("\n%04X: Addr:%04X %07o  Inst: %06o PeriAd:%02X Data56:%08X",
	     i,
	     trans_addr[i],
	     trans_addr[i],
	     trans_instruction[i],
	     trans_pa[i],
	     trans_data56[i]);
    }
  
  printf("\n");
}

////////////////////////////////////////////////////////////////////////////////
//
// Press a key
//
////////////////////////////////////////////////////////////////////////////////

struct
{
  char *name;
  int key_r;
  int key_c;
} key_def[] =
  {
   {"0",     7, 1},
   {"1",     6, 1},
   {"2",     6, 2},
   {"3",     6, 3},
   {"4",     5, 1},
   {"5",     5, 2},
   {"6",     5, 3},
   {"7",     4, 1},
   {"8",     4, 2},
   {"9",     4, 3},
   {"R/S",   7, 3},
   {".",     7, 2},
   {"/",     7, 0},
   {"*",     6, 0},
   {"+",     5, 0},
   {"-",     4, 0},
   {"ENTER", 3, 0},
   {"CHS",   3, 2},
   {"EEX",   3, 3},
   {"<-",    3, 4},
   {"SHIFT", 2, 0},
   {"XEQ",   2, 1},
   {"STO",   2, 2},
   {"RCL",   2, 3},
   {"SST",   2, 4},
   {"X<>Y",  1, 0},
   {"RDN",    1, 1},
   {"SIN",   1, 2},
   {"COS",   1, 3},
   {"TAN",   1, 4},
   {"E+",    0, 0},
   {"1/X",   0, 1},
   {"SQRX",  0, 2},
   {"LOG",   0, 3},
   {"LN",    0, 4},
   //   {"ON",    0, 0},
   {"USER",  6, 4},
   {"PRGM",  5, 4},
   {"ALPHA", 4, 4},
   {"A",     0, 0},
   {"B",     0, 1},
   {"C",     0, 2},
   {"D",     0, 3},
   {"E",     0, 4},
   {"F",     1, 0},
   {"G",     1, 1},
   {"H",     1, 2},
   {"I",     1, 3},
   {"J",     1, 4},
   {"K",     2, 1},
   {"L",     2, 2},
   {"M",     2, 3},
   {"N",     3, 0},
   {"O",     3, 2},
   {"P",     3, 3},
   {"Q",     4, 0},
   {"R",     4, 1},
   {"S",     4, 2},
   {"T",     4, 3},
   {"U",     5, 0},
   {"V",     5, 1},
   {"W",     5, 2},
   {"X",     5, 3},
   {"Y",     6, 0},
   {"Z",     6, 1},
   {"=",     6, 2},
   {"?",     6, 3},
   {":",     7, 0},
   {" ",     7, 1},
   {",",     7, 2},
   
   {"", 0, 0},
  };

void setrow(int row)
{
  row ^=0x7;
  if( row & 1 )
    {
      gpio_put(P_KRA, 1);
    }
  else
    {
      gpio_put(P_KRA, 0);
    }
  
  if( row & 2 )
    {
      gpio_put(P_KRB, 1);
    }
  else
    {
      gpio_put(P_KRB, 0);
    }
  
  if( row & 4 )
    {
      gpio_put(P_KRC, 1);
    }
  else
    {
      gpio_put(P_KRC, 0);
    }
}

void setcol(int col)
{
  col ^=0x7;
  if( col & 1 )
    {
      gpio_put(P_KCA, 1);
    }
  else
    {
      gpio_put(P_KCA, 0);
    }
  
  if( col & 2 )
    {
      gpio_put(P_KCB, 1);
    }
  else
    {
      gpio_put(P_KCB, 0);
    }
  
  if( col & 4 )
    {
      gpio_put(P_KCC, 1);
    }
  else
    {
      gpio_put(P_KCC, 0);
    }
}

int getnumdigit(void)
{
  int key;
  int val = 0;
  
  while( ((key = getchar_timeout_us(1000)) == PICO_ERROR_TIMEOUT))
    {
    }

  switch(key)
    {
    case'0':
    case'1':
    case'2':
    case'3':
    case'4':
    case'5':
    case'6':
    case'7':
    case'8':
    case'9':
      val = key - '0';
      break;
    }

  return(val);
  
}


void kb_setrow(void)
{
  int c = getnumdigit();
  setrow(c);
  printf("\nSet row to %d\n", c);
}

void kb_setcol(void)
{
  int c = getnumdigit();
  setcol(c);
  printf("\nSet col to %d\n", c);
}

char upkey[MAX_KWB];

void press_key(char *key)
{
  int quick_key = 0;
  char qk[2] = {' ', '\0'};
  
  // Check for commands
  if( strcmp(key, "QUICK1")==0 )
    {
      qk[0] = '1';
      key = &(qk[0]);
      quick_key = 1;
    }

  if( strcmp(key, "WAIT1")==0 )
    {
      sleep_ms(2000);
      return;
    }

  if( strcmp(key, "R/S")==0 )
    {
      sleep_ms(100);
    }
  
  gpio_put(P_KB_INH, 0);
  sleep_ms(PRESS_DELAY_1);

  int i=0;

  while((*key)!= '\0' )
    {
      upkey[i++] = toupper(*(key++));
    }

  upkey[i] = '\0';
  
  // KC1 KR6 = '1'
  for(int i=0; ;i++)
    {
      if( strlen(key_def[i].name) == 0)
	{
	  break;
	}
      
      if( strcmp(upkey, key_def[i].name)==0 )
	{
#if CF_DBG_KEY
	  printf("\nFound key '%s'", upkey);
#endif
	  // Found the key, press it
	  setrow(key_def[i].key_r);
	  setcol(key_def[i].key_c);
	  
	  // Press the key
	  gpio_put(P_KB_INH, 1);
	  sleep_ms(PRESS_DELAY_1);
	  gpio_put(P_KB_INH, 0);
	  if( quick_key )
	    {
	      sleep_ms(50);
	    }
	  else
	    {
	      sleep_ms(PRESS_DELAY_1);
	    }
	  
	  // Certain keys need longer delays
	  if( isdigit(*upkey) )
	    {
	      sleep_ms(PRESS_DELAY_1*4);
	    }
	  
	  if( strcmp(upkey, "ALPHA") == 0 )
	    {
	      sleep_ms(PRESS_DELAY_2);
	    }

	  if( strcmp(upkey, "XEQ") == 0 )
	    {
	      sleep_ms(PRESS_DELAY_2);
	    }

	  if( strcmp(upkey, ".") == 0 )
	    {
	      sleep_ms(PRESS_DELAY_1*4);
	    }

	  if( strcmp(upkey, "EEX") == 0 )
	    {
	      sleep_ms(PRESS_DELAY_1*4);
	    }
	  break;
	}
    }
}

void kb_inhibit(void)
{
  gpio_put(P_KB_INH, 1);
}

void kb_uninhibit(void)
{
  gpio_put(P_KB_INH, 0);
}

void kb_active(void)
{
  gpio_put(P_KCA, 1);
  gpio_put(P_KCB, 1);
  gpio_put(P_KCC, 1);
  gpio_put(P_KCA, 1);
  gpio_put(P_KCB, 1);
  gpio_put(P_KCC, 1);
}

////////////////////////////////////////////////////////////////////////////////
//
// Receive characters and try to send the corresponding keys
//
// 'xxx types the string xxx
//

void press_keys(void)
{
  int key;
  char key_word_buffer[MAX_KWB+2] = "\0";
  int kwb_i = 0;

  printf("\nKey Entry\n");
  
  while( 1 )
    {
      process_bus();
      
      if( ((key = getchar_timeout_us(1000)) != PICO_ERROR_TIMEOUT) )
	{
	  // Got another character
	  // If it's whitespace then we heck the buffer against the
	  // list of known commands
	  if( isspace(key) && (key != ' '))
	    {
	      // Terminate buffer
	      key_word_buffer[kwb_i++] = '\0';
	      
	      // Check buffer and see if we have a known key word
	      // If not, discard the buffer

	      // Check for exit key words
	      if( strcmp(key_word_buffer, "quit")==0 )
		{
		  return;
		}

	      if( strcmp(key_word_buffer, "exit")==0 )
		{
		  return;
		}

	      // Check for a string
	      if( key_word_buffer[0] == '\'' )
		{
		  // Send each character in the string
		  char *j = &(key_word_buffer[1]);
		  char single_key[2];
		  single_key[1] = '\0';
		  
		  while(*j != '\0' )
		    {
		      single_key[0] = *(j++);
		      press_key(single_key);
		    }
		}
	      else
		{
		  // Press the key (if not found then nothing happens)
		  press_key(key_word_buffer);
		}
	      
	      // Clear buffer
	      key_word_buffer[0] = '\0';
	      kwb_i = 0;
	      
	    }
	  else
	    {
	      // Add to buffer
	      key_word_buffer[kwb_i++] = key;
	      key_word_buffer[kwb_i] = '\0';
	      
	      // Limit buffer writes
	      if( kwb_i >= MAX_KWB )
		{
		  kwb_i = MAX_KWB-1;
		}

	      printf("\nKWB: '%s'", key_word_buffer);
	    }
	}
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// Send PI as a test of key presses
//

void press_pi(void)
{
  press_key("3");
  press_key(".");
  press_key("1");
  press_key("4");
  press_key("1");
  press_key("5");
  press_key("9");
  press_key("2");
  press_key("6");
  press_key("5");
  press_key("3");
  press_key("5");
  press_key("8");
}

////////////////////////////////////////////////////////////////////////////////
//
// Check the line against the program and then press SST
//

int mismatches = 0;

void check_prog_line(char *line_text)
{
  if( strncmp(dtext, line_text, strlen(line_text)) == 0 )
    {
      // All OK
    }
  else
    {
      // Mismatch
      printf("\n**Mismatch Stored line '%s' not equal to '%s'", dtext, line_text);
      mismatches++;
    }

  // Move to next line
  press_key("SST");
}

////////////////////////////////////////////////////////////////////////////////

void press_embedded(void)
{
  for(int i=0; i<(sizeof(embed_keys)/sizeof(char *)); i++)
    {
      press_key(embed_keys[i]);
      process_bus();
    }
}

////////////////////////////////////////////////////////////////////////////////
void press_byte_grabber(void)
{
  for(int i=0; i<(sizeof(byte_grabber_keys)/sizeof(char *)); i++)
    {
      press_key(byte_grabber_keys[i]);
    }
}

////////////////////////////////////////////////////////////////////////////////

void check_prog(void)
{
  mismatches = 0;
  for(int i=0; i<(sizeof(embed_prog)/sizeof(char *)); i++)
    {
      check_prog_line(embed_prog[i]);
      process_bus();
    }

  printf("\n%d mismatched lines\n", mismatches);
}

////////////////////////////////////////////////////////////////////////////////

void arith_test(void)
{
  uint64_t x = 0xaaaabbbb;
  uint64_t y = 0xf;

  uint64_t z = (x & y) << 44;

  printf("\nz:%016llX\n", z);
}

////////////////////////////////////////////////////////////////////////////////
//
//
//
////////////////////////////////////////////////////////////////////////////////

void serial_help(void);

void capture_bus_fragment_on_c1(void)
{
  core1_command = 1;
}

void isa_drive(void)
{
  printf("\nISA drive ount:             %d", driven_isa);
  printf("\nEmbedded ROM address count: %d", embed_seen);
  printf("\nSync count:                 %d", sync_count);
}

SERIAL_COMMAND serial_cmds[] =
  {
   {
    'h',
    "Serial command help",
    serial_help,
   },
   {
    '?',
    "Serial command help",
    serial_help,
   },
   {
    'b',
    "Display bus states",
    display_bus_states,
   },
   
   {
    '1',
    "Capture bus fragment on core 1",
    capture_bus_fragment_on_c1,
   },
   
   {
    'C',
    "Capture bus fragment",
    capture_bus_fragment,
   },
   {
    'c',
    "Display captured bus fragment",
    display_captured_bus_fragment,
   },
   {
    't',
    "Capture bus transactions",
    capture_bus_transactions,
   },
   {
    'u',
    "uninhibit kb",
    kb_uninhibit,
   },
   {
    'i',
    "inhibit kb",
    kb_inhibit,
   },
   {
    'x',
    "Set row",
    kb_setrow,
   },
   {
    'y',
    "Set col",
    kb_setcol,
   },
   {
    '=',
    "Set active key",
    kb_active,
   },
   
   {
    'K',
    "Press Keys",
    press_keys,
   },
   {
    'k',
    "Press PI",
    press_pi,
   },
   {
    '*',
    "Arithmetic test",
    arith_test,
   },
   {
    'd',
    "ISA drive count",
    isa_drive,
   },
   {
    'G',
    "Press byte grabber keystrokes",
    press_byte_grabber,
   },
   {
    '!',
    "Press embedded keystrokes",
    press_embedded,
   },
   {
    '%',
    "Check embedded program",
    check_prog,
   },
  };


void serial_help(void)
{
  for(int i=0; i<sizeof(serial_cmds)/sizeof(SERIAL_COMMAND);i++)
    {
      printf("\n%c: %s", serial_cmds[i].key, serial_cmds[i].desc);
    }
  printf("\n");
}

////////////////////////////////////////////////////////////////////////////////
//
//
//
////////////////////////////////////////////////////////////////////////////////

int pcount = 0;
int periodic_read = 0;

void serial_loop()
{
  int  key;
  int periodic_key = 0;

  if( periodic_read )
    {
      pcount++;
    }
  
  if( pcount >= 500 )
    {
      periodic_key = '0';
      pcount = 0;
    }
  
  if( ((key = getchar_timeout_us(1000)) != PICO_ERROR_TIMEOUT) || (periodic_key != 0))
    {
      if( periodic_key != 0 )
	{
	  key = periodic_key;
	  periodic_key = 0;
	}
      
      //      printf("\nkey %d", key);
      
      //char buf[15];
      //sprintf(buf, "(Ard) In: 0x%02x", byte(key)); // print input character
      //printf(buf);
      
      for(int i=0; i<sizeof(serial_cmds)/sizeof(SERIAL_COMMAND);i++)
	{
	  if( serial_cmds[i].key == key )
	    {
	      (*serial_cmds[i].fn)();
	      break;
	    }
	}
      
    }
  else
    {
      // I have found that I need to send something if the serial USB times out
      // otherwise I get lockups on the serial communications.
      // So, if we get a timeout we send a spoace and backspace it. And
      // flush the stdio, but that didn't fix the problem but seems like a good idea.
      stdio_flush();
      printf(" \b");
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// Core 1 sits in a loop grabbing bus cycles
//

int last_clk1 = 0;
int last_clk2 = 0;
int last_isa  = 0;
int last_data = 0;

int clk1 = 0;
int clk2 = 0;
int isa  = 0;

#define RISING_EDGE(SIGNAL)  ((last_ ## SIGNAL==0) && (SIGNAL==1))
#define FALLING_EDGE(SIGNAL) ((last_ ## SIGNAL==1) && (SIGNAL==0))

#define NUM_DUMP 100
#define NUM_DUMP_SIGNAL 300

int dump_i = 0;
long dump_frames[NUM_DUMP];

int dump_signal_i = 0;
int dump_sync[NUM_DUMP_SIGNAL];

#define DIRECT_GPIO 1

////////////////////////////////////////////////////////////////////////////////
//
// Core1 main functions
//
// Various different core 1 main functions used to test functionality
//
////////////////////////////////////////////////////////////////////////////////

// Data transfer to core 0

#define NUM_BUS_T  7000

int queue_overflow = 0;

volatile int data_in = 0;
volatile int data_out = 0;

volatile int bus_addr[NUM_BUS_T];
volatile int bus_inst[NUM_BUS_T];
volatile int bus_pa[NUM_BUS_T];
volatile uint64_t  bus_data56[NUM_BUS_T];
int last_sync   = 0;
int trans_i     = 0;
int data        = 0;
int periph_addr = 0;
int instruction = 0;
int bit_no      = 0;
int gpio_states = 0;
int sync        = 0;
int address     = 0;
uint64_t data56      = 0;

void core1_main_3(void)
{

  irq_set_mask_enabled(0xffffffff, false);
    
  gpio_states = sio_hw->gpio_in;
  last_sync = gpio_states & (1<<P_SYNC);  

  while(1)
    {
      // Wait for CLK2 to have a falling edge
      // Wait while low
      while( ((gpio_states = sio_hw->gpio_in) & (1 << P_CLK2)) == 0 )
	{
	}

      while( ((gpio_states = sio_hw->gpio_in) & (1 << P_CLK2)) != 0 )
	{
	}

      // Another bit, check SYNC to find bit number
      sync = gpio_states & (1<<P_SYNC);

      // Do we drive the ISA line?
      // Bit numbers are out by one as bit_no hasn't been incremented yet.
      
      if( (bit_no >= 43) && (bit_no <= 52) )
	{
	  if( /*(sync!=0) &&*/ drive_data_flag )
	    {
	      // Drive the ISA line for this data bit
	      gpio_put(P_ISA_OE, 0);
	      gpio_put(P_ISA_DRV, (drive_data & 1));
	      drive_data >>= 1;
	      driven_isa++;
	    }
	  else
	    {
	      // Do not drive data
	      gpio_put(P_ISA_OE, 1);
	    }
	}

      if( bit_no == 52 )
	{
	  // Don't drive data any more
	  drive_data_flag = 0;
	}

      if( bit_no == 53 )
	{
	  // Don't drive data any more
	  gpio_put(P_ISA_OE, 1);
	}
      
      // Now high, wait for falling edge
      while( ((gpio_states = sio_hw->gpio_in) & (1 << P_CLK1)) == 0 )
	{
	}

      // Now high, wait for falling edge
      while( ((gpio_states = sio_hw->gpio_in) & (1 << P_CLK1)) != 0 )
	{
	}

      // Another bit, check SYNC to find bit number
      sync = gpio_states & (1<<P_SYNC);


      if( (last_sync == 0) && (sync != 0) )
	{
	  sync_count++;
	  bit_no = 44;
	}
      else
	{
	  bit_no = (bit_no + 1) % 56;
	}
      
      // Get data and put into data or instruction if bit no is OK for those fields
      // If the SYNC is high and we are to drive the ISA line then if we have embedded data
      // then we drive the ISA line.
      
      if( (bit_no >= 44) && (bit_no <= 53) )
	{
	  instruction |= ((gpio_states & (1<<P_ISA))>>(P_ISA)) << ((bit_no - 44));
	}

      
      if( (bit_no >= 14) && (bit_no <= 29) )
	{
	  address |= ((gpio_states & (1<<P_ISA))>>(P_ISA)) << ((bit_no - 14));
	}
      
      // Got address. If the address is that of the embedded ROM then we flag that we have
      // to put an instruction on the bus later
      if( bit_no == 29 )
	{
	  if( (address >= LOW_EMBED_ROM_ADDR) && (address <= HIGH_EMBED_ROM_ADDR) )
	    {
	      embed_seen++;
	      drive_data_flag = 1;
	      drive_data = embed_rom[address-LOW_EMBED_ROM_ADDR];
	    }
	  else
	    {
	      drive_data_flag = 0;
	    }
	}
      
      if( (bit_no >= 0) && (bit_no <= 7) )
	{
	  periph_addr |= ((gpio_states & (1<<P_DATA))>>(P_DATA)) << ((bit_no - 0));
	}

      if( (bit_no >= 0) && (bit_no <= 55) )
	{
	  uint64_t v;
	  v = ((gpio_states & (1<<P_DATA))>>(P_DATA));
	  v <<= ((bit_no - 0));
	  data56 |= v;
	}
      
      // If bitno = 55 then we have another frame, store the transaction
      if( bit_no == 55 )
	{
	  // A 56 bit frame has completed, we send some information to core0 so it can update
	  // the display and anything else it needs to

	  bus_addr[data_in] = address;
	  bus_inst[data_in] = instruction;
	  bus_pa[data_in] = periph_addr;
	  bus_data56[data_in] = data56;

	  address = 0;
	  instruction = 0;
	  periph_addr = 0;
	  data56 = 0;
	  
	  int last_data_in = data_in;
	  
	  data_in = (data_in+1) % NUM_BUS_T;

	  if( data_out == data_in )
	    {
	      // No space
	      queue_overflow = 1;
	      data_in = last_data_in ;
	    }
	  else
	    {
	    }
	}
      
      last_sync = sync;
    }
}


void core1_main2(void)
{
  // Disable interrupts
  irq_set_mask_enabled(0xffffffff, false);

  while(1)
    {
      
      // Sit waiting for a command to do
      while(core1_command == 0 )
	{
	}
      
      // We have a comamnd, do it
      switch(core1_command)
	{
	case 1:
	  capture_bus_fragment();
	  break;
	  
	}

      // Clear the command
      core1_command = 0;
    }
  
}



int core1_main(void)
{
  int gpios = 0;
  
  oled_set_xy(&oled0, 0, 30);
  oled_display_string(&oled0, "Core 1");
  
  last_clk1 = gpio_get(P_CLK1);
  last_clk2 = gpio_get(P_CLK2);
  last_isa  = gpio_get(P_ISA);
  last_sync = gpio_get(P_SYNC);
  last_data = gpio_get(P_DATA);
  
  while(1)
    {
#if 0
      // Sync to clk2
      while(1)
	{
	  clk1 = gpio_get(P_CLK1);
	  if( RISING_EDGE(clk1) )
	    {
	      break;
	    }
	  last_clk1 = clk1;
	}
#endif

#if DIRECT_GPIO
      gpios = sio_hw->gpio_in;
      clk1 = (gpios >> P_CLK1) & 1;
      clk2 = (gpios >> P_CLK2) & 1;
      sync = (gpios >> P_SYNC) & 1;
      isa  = (gpios >> P_ISA) & 1;
      data = (gpios >> P_DATA) & 1;
#else
      clk1 = gpio_get(P_CLK1);
      clk2 = gpio_get(P_CLK2);
      isa  = gpio_get(P_ISA);
      sync = gpio_get(P_SYNC);
      data = gpio_get(P_DATA);
#endif

      // Wait for clk2 edge
      //      if( RISING_EDGE(clk2) )
      //	{
	  // Capture 
	  if( dump_signal_i< NUM_DUMP_SIGNAL )
	    {
	      dump_sync[dump_signal_i++] = clk1;
	    }
	  //	}

	  last_clk1 = clk1;
	  last_clk2 = clk2;
	  last_isa  = isa ;
	  last_sync = sync;
	  last_data = data;
    }
}

int every_4th_bit(uint64_t data, int n)
{
  int val = 0;
  
  for(int i=0; i<n; i++)
    {
      val |= ((data & (1<< (i*4))) >> (i*4))<<i;
    }
  
  return(val);
}

////////////////////////////////////////////////////////////////////////////////
//
// This function is passed all of the traffic on the bus. It can do
// various things with that.
//

int pending_data = 0;
int pending_data_inst = 0;

uint64_t dreg_a = 0, dreg_b = 0;
int dreg_c = 0;
int display_on = 0;

void dump_dregs(void)
{
  int i;

  // If the display is off, we don't up date anything
  if( !display_on )
    {
      return;
    }
  
  dreg_a &= MASK_48_BIT;
  dreg_b &= MASK_48_BIT;
  
#if CF_DUMP_DBG_DREGS  
  printf("\nA:%016llX B:%016llX C:%02X", dreg_a, dreg_b, dreg_c);
#endif
  
  // Build a text form of the display

#if CF_DUMP_DBG_DREGS  
  printf("\n'");
#endif
  
  int j = 0;
  
  for(i=0; i<12; i++)
    {
      char cc = 0;
      char cl = 0;
      int  u = 0;
      
      uint64_t m = 0xf;
      int b1 = (11-i);
      int b = 4*b1;
      
      cc |= (((m << b) & dreg_a) >> b) << 0;
      cc |= (((m << b) & dreg_b) >> b) << 4;
      u = ((1<<b1) & dreg_c) >> b1;
      
      cl = cc & 0xc0;
      cc &= 0x3f;
      
      if( (cc >= 0x01) &&
	  (cc <= 0x1A) )
	{
	  if( u )
	    {
	      // Upper ROM character
	      switch(cc)
		{
		case 0x0d:
		  cc = '#';
		  break;
		}
	      
	    }
	  else
	    {
	      // Convert to ASCII character
	      cc |= 0x40;	  
	      dtext[j++] = cc;
#if CF_DUMP_DBG_DREGS  	  
	      printf("%c", cc);
#endif
	    }
	}
      else
	{
	  
	  switch(cc)
	    {
	      
	    case 0x00:
	      cc = '@';
	      dtext[j++] = cc;
#if CF_DUMP_DBG_DREGS  
	      printf("%c", cc);
#endif
	      break;

	    case 0x1F:
	      cc = '_';
	      dtext[j++] = cc;
#if CF_DUMP_DBG_DREGS  
	      printf("%c", cc);
#endif
	      break;

	    default:
	      dtext[j++] = cc & 0x3f;
#if CF_DUMP_DBG_DREGS  
	      printf("%c", cc & 0x3f);
#endif
	      break;
	    }
	}


      
      if( cl )
	{
	  switch(cl)
	    {
	    case 0x40:
	      dtext[j++] = '.';
#if CF_DUMP_DBG_DREGS  
	      printf(".");
#endif
	      break;
	    case 0x80:
	      dtext[j++] = ':';
#if CF_DUMP_DBG_DREGS  
	      printf(":");
#endif
	      break;
	    case 0xC0:
	      dtext[j++] = ',';
#if CF_DUMP_DBG_DREGS  
	      printf(",");
#endif
	      break;
	    }
	}


    }
#if CF_DUMP_DBG_DREGS  
  printf("'");
#endif
  dtext[j++] = '\0';

#if CF_DISPLAY_LCD  
  printf("\n[%s]", dtext);
#endif
  
  while( strlen(dtext) < 15 )
    {
      strcat(dtext, " ");
    }

#if CF_DISPLAY_OLED
  oled_set_xy(&oled0, 0, 16);
  oled_display_string(&oled0, dtext);
#endif
  
}

uint64_t x;
uint64_t z;
uint64_t y;

void handle_bus(int  addr, int inst, int pa, uint64_t data56)
{
  //printf("\nDCE:%d ADDR:%04X (%o) INST=%04X (%o)", display_ce, addr, addr, inst, inst);
  
  // Check for a pending instruction from the previous cycle
  if( pending_data )
    {
      pending_data = 0;

      switch(pending_data_inst )
	{
	case INST_PRPH_SLCT:
#if CF_DBG_SLCT
	  printf("\nPF AD:%02X", pa);
#endif
	  if( pa == 0xFD )
	    {
	      display_ce = 1;
	    }
	  else
	    {
	      display_ce = 0;
	    }
	  break;
	  
	case INST_SRLAD:
#if CF_DBG_DISP_INST
	  printf("\nSRLAD %016llX", data56);
#endif
	  // Load 48 bits into A register
	  dreg_a = data56 & (MASK_48_BIT);
	  dump_dregs();
	  break;

	case INST_SRLDB:
#if CF_DBG_DISP_INST
	  printf("\nSRLDB %016llX", data56);
#endif
	  dreg_b = data56 & (MASK_48_BIT);
	  dump_dregs();

	  break;

	case INST_SRLDC:
#if CF_DBG_DISP_INST
	  printf("\nSRLDC %016llX", data56);
#endif
	  dreg_c = every_4th_bit(data56 & (MASK_48_BIT), 12);
	  dump_dregs();
	  break;

	case INST_SRSDABC:
#if CF_DBG_DISP_INST
	  printf("\nSRSDABC %llX", data56);
#endif
	  dreg_a >>= 4;
	  dreg_b >>= 4;

	  y = data56;
#if CF_DBG_DISP_INST
	  printf("  data56:%llX", data56);
#endif
	  
	  y = data56 & 0xF;
#if CF_DBG_DISP_INST
	  printf("  Y:%016llX", y);
#endif

	  y <<= 44;
#if CF_DBG_DISP_INST
	  printf("  Y:%016llX", y);
#endif

	  //y = (x & z) << 44;
	  //printf("\nY:%016llX", y);
	  
	  //dreg_a |= (data56 & 0xF)  << (11*4);
	  dreg_a |= y;
	  dreg_b |= (data56 & 0xF0) << 40;
	  dump_dregs();
	  break;

	case INST_SRLDABC:
#if CF_DBG_DISP_INST
	  printf("\nSRLDABC %llX", data56);
#endif

	  for(int i=0; i<4; i++)
	    {
	      dreg_a >>= 4;
	      dreg_b >>= 4;
	      
	      y = data56;
#if CF_DBG_DISP_INST
	      printf("  data56:%llX", data56);
#endif
	      
	      y = data56 & 0xF;
#if CF_DBG_DISP_INST
	      printf("  Y:%016llX", y);
#endif
	      
	      y <<= 44;
#if CF_DBG_DISP_INST
	      printf("  Y:%016llX", y);
#endif
	      
	      //y = (x & z) << 44;
	      //printf("\nY:%016llX", y);
	      
	      //dreg_a |= (data56 & 0xF)  << (11*4);
	      dreg_a |= y;
	      dreg_b |= (data56 & 0xF0) << 40;

	      data56 >>= 12;
	    }
	      dump_dregs();
	  break;

	case INST_SLSDABC:
#if CF_DBG_DISP_INST
	  printf("\nSLSDABC %llX", data56);
#endif
	  dreg_a <<= 4;
	  dreg_b <<= 4;

	  y = data56;
#if CF_DBG_DISP_INST
	  printf("  data56:%llX", data56);
#endif
	  
	  y = data56 & 0xF;
#if CF_DBG_DISP_INST
	  printf("  Y:%016llX", y);
#endif

	  y <<= 0;
#if CF_DBG_DISP_INST
	  printf("  Y:%016llX", y);
#endif

	  //y = (x & z) << 44;
	  //printf("\nY:%016llX", y);
	  
	  //dreg_a |= (data56 & 0xF)  << (11*4);
	  dreg_a |= y;
	  dreg_b |= (data56 & 0xF0) >> 4;
	  dump_dregs();
	  break;
	}
    }

  switch(inst)
    {
    case INST_DISPLAY_OFF:
#if CF_DBG_DISP_ON
      printf("\nDisplay off");
#endif
      display_on = 0;
      break;
      
    case INST_DISPLAY_TOGGLE:
#if CF_DBG_DISP_ON
      printf("\nDisplay toggle");
#endif
      display_on = !display_on;
      break;
      
    case INST_PRPH_SLCT:
      pending_data = 1;
      pending_data_inst = INST_PRPH_SLCT;
      break;
    }

  // Check for instructions
  switch(inst)
    {
    case INST_PRPH_SLCT:
#if CF_DBG_SLCT
      printf("\nPRPH_SLCT: PA=%02X", pa);
#endif      
      break;

    case INST_RAM_SLCT:
#if CF_DBG_SLCT      
      printf("\nRAM_SLCT: PA=%02X", pa);
#endif
      break;
    }
  
  // Check for display transactions
  if( display_ce )
    {
      switch(inst)
	{
	case INST_SRLDAB:
#if CF_DBG_DISP_INST
	  printf("\nSRLDAB");
#endif
	  break;

	case INST_SRLDABC:
#if CF_DBG_DISP_INST
	  printf("\nSRLDABC");
#endif
	  pending_data = 1;
	  pending_data_inst = INST_SRLDABC;
	  break;

	case INST_SRLAD:
#if CF_DBG_DISP_INST
	  printf("\nSRLAD");
#endif
	  pending_data = 1;
	  pending_data_inst = INST_SRLAD;
	  break;
	  
	case INST_SRLDB:
#if CF_DBG_DISP_INST
	  printf("\nSRLDB");
#endif
	  pending_data = 1;
	  pending_data_inst = INST_SRLDB;
	  break;
	  
	case INST_SRLDC:
#if CF_DBG_DISP_INST
	  printf("\nSRLDC");
#endif
	  pending_data = 1;
	  pending_data_inst = INST_SRLDC;
	  break;
	  
	case INST_SLLDABC:
#if CF_DBG_DISP_INST
	  printf("\nSLLDABC");
#endif
	  break;
	  
	case INST_SRSDA:
#if CF_DBG_DISP_INST
	  printf("\nSRSDA");
#endif
	  break;
	  
	case INST_SRSDB:
#if CF_DBG_DISP_INST
	  printf("\nSRSDB");
#endif
	  break;
	  
	case INST_SRSDC:
#if CF_DBG_DISP_INST
	  printf("\nSRSDC");
#endif
	  break;
	  
	case INST_SLSDA:
#if CF_DBG_DISP_INST
	  printf("\nSLSDA");
#endif
	  break;
	  
	case INST_SLSDB:
#if CF_DBG_DISP_INST
	  printf("\nSLSDB");
#endif
	  break;
	  
	case INST_SRSDAB:
#if CF_DBG_DISP_INST
	  printf("\nSRSDAB");
#endif
	  break;
	  
	case INST_SLSDAB:
#if CF_DBG_DISP_INST
	  printf("\nSLSDAB");
#endif
	  break;
	  
	case INST_SRSDABC:
#if CF_DBG_DISP_INST
	  printf("\nSRSDABC data56:%08llX", data56);
#endif
	  pending_data = 1;
	  pending_data_inst = INST_SRSDABC;
	  break;

	case INST_SLSDABC:
#if CF_DBG_DISP_INST
	  printf("\nSLSDABC");
#endif
	  pending_data = 1;
	  pending_data_inst = INST_SLSDABC;
	  break;

	case INST_FLLDA:
#if CF_DBG_DISP_INST
	  printf("\nFLLDA:");
#endif
	  break;

	case INST_FLLDB:
#if CF_DBG_DISP_INST
	  printf("\nFLLDB:");
#endif
	  break;

	case INST_FLLDC:
#if CF_DBG_DISP_INST
	  printf("\nFLLDC:");
#endif
	  break;
	  
	case INST_FLLDAB:
#if CF_DBG_DISP_INST
	  printf("\nFLLDAB:");
#endif
	  break;
	  
	case INST_FLLDABC:
#if CF_DBG_DISP_INST
	  printf("\nFLLDABC:");
#endif
	  break;

	case INST_FLSDC:
#if CF_DBG_DISP_INST
	  printf("\nFLSDC:");
#endif
	  break;

	case INST_FRSDA:
#if CF_DBG_DISP_INST
	  printf("\nFRSDA:");
#endif
	  break;

	case INST_FRSDB:
#if CF_DBG_DISP_INST
	  printf("\nFRSDB:");
#endif
	  break;

	case INST_FRSDC:
#if CF_DBG_DISP_INST
	  printf("\nFRSDC:");
#endif
	  break;

	case INST_FLSDA:
#if CF_DBG_DISP_INST
	  printf("\nFLSDA:");
#endif
	  break;
	case INST_FLSDB:
#if CF_DBG_DISP_INST
	  printf("\nFLSDB:");
#endif
	  break;
	case INST_FRSDAB:
#if CF_DBG_DISP_INST
	  printf("\nFRSDAB:");
#endif
	  break;
	case INST_FLSDAB:
#if CF_DBG_DISP_INST
	  printf("\nFLSDAB:");
#endif
	  break;

	case INST_FRSDABC:
#if CF_DBG_DISP_INST
	  printf("\nFRSDABC data56:%016llX", data56);
#endif
	  ROTATE_RIGHT(dreg_a);
	  ROTATE_RIGHT(dreg_b);
	  dump_dregs();
	  break;
	  
	case INST_FLSDABC:
#if CF_DBG_DISP_INST
	  printf("\nFLSDABC:");
#endif
	  ROTATE_LEFT(dreg_a);
	  ROTATE_LEFT(dreg_b);
	  dump_dregs();
	  break;

	}
    }
}


////////////////////////////////////////////////////////////////////////////////

#define NUMB 4096
int buffer_i = 0;

int buffer[NUMB];

int gpios2 = 0;
int clk1;
uint64_t data_value = 0;
uint64_t isa_value = 0;

#define NUM_VL 256
int value_list_i = 0;
uint64_t value_list[NUM_VL];

int isa_list_i = 0;
uint64_t isa_list[NUM_VL];

BYTE bitnum = 0;

void process_bus(void)
{
#if 1
      //Process data coming in from the bus via core 1
      while( data_in != data_out )
	{
#if 0
	  printf("\n%d: Addr:%04X %07o  Inst: %06o PeriAd:%02X Data56:%016llX",
		 data_out,
		 bus_addr[data_out],
		 bus_addr[data_out],
		 bus_inst[data_out],
		 bus_pa[data_out],
		 bus_data56[data_out]);
#endif
	  // Handle the bus traffic
	  handle_bus(bus_addr[data_out], bus_inst[data_out], bus_pa[data_out], bus_data56[data_out]);
	  data_out = (data_out + 1) % NUM_BUS_T;
	}
#endif      
}

int main(void)
{
  
  ////////////////////////////////////////////////////////////////////////////////
  //
  // Overclock as needed
  //
  ////////////////////////////////////////////////////////////////////////////////
  
  //#define OVERCLOCK 135000
  //#define OVERCLOCK 200000
#define OVERCLOCK 270000
  //#define OVERCLOCK 360000
  
#if OVERCLOCK > 270000
  /* Above this speed needs increased voltage */
  vreg_set_voltage(VREG_VOLTAGE_1_20);
  sleep_ms(1000);
#endif
  
  /* Overclock */
  set_sys_clock_khz( OVERCLOCK, 1 );

  stdio_init_all();

  sleep_ms(2000);

  printf("\n*************");
  printf("\n*  Pico 41  *");
  printf("\n*************");
  printf("\n");
  
  printf("\nSetting up OLED...");
  
   // Set up OLED display
  i2c_init(&i2c_bus_0);
    
  oled_setup(&oled0);
  
  oled_set_xy(&oled0, 0, 8);
  oled_display_string(&oled0, "Pico41");



#if 1
  printf("\nSetting up kbd...");
  kb_init();

  printf("\nSetting up drv...");
  drv_init();

  printf("\nSetting up bus...");
  bus_init();
#endif
  
  //multicore_launch_core1(core1_main2);

#if 0
  // Sit in a loop processing things
  while(1)
    {
      
      // Synchronise to clk1 edge
      while(1)
	{
	  // get GPIO states
	  gpios2 = sio_hw->gpio_in;
	  
	  clk2 = gpios2 & (1<<P_CLK2);
	  
	  if( (last_clk2==0) && (clk2!=0) )
	    {
	      break;
	    }
	  last_clk2 = clk2;
	}
      
      // Rising edge of clk1 has occurred
      bitnum++;
      if( bitnum > 55 )
	{
	  bitnum = 0;
	}
      
      //      buffer[buffer_i] = gpio_get(P_CLK1);
      buffer[buffer_i++] = gpios2 & ((1 << P_CLK1) |(1 << P_CLK2) | (1<<P_SYNC) | (1<<P_DATA)| (1<<P_ISA));
      
      isa  = gpios2 & (1<<P_ISA);
      data = gpios2 & (1<<P_DATA);
      sync = gpios2 & (1<<P_SYNC);
      
      if( (last_sync!=0) && (sync==0) )
	{
	  bitnum = 54;
	}

      if( bitnum == 0 )
	{
	  // End of instruction so store and reset  data
	  value_list[value_list_i++] = data_value;
	  value_list_i &= (NUM_VL -1);
	  data_value = 0;
	  isa_list[isa_list_i++] = isa_value;
	  isa_list_i &= (NUM_VL -1);
	  isa_value = 0;
	}
      
      // Shift data in
      //      data_value >>= 1;
      if( data )
	{
	  data_value |= ((uint64_t)1)<<bitnum;
	}

      // Shift ISA in
      //isa_value >>= 1;
      if( isa )
	{
	  isa_value |= ((uint64_t)1)<<bitnum;
	}
      
      last_sync = sync;
      
      if( buffer_i >= NUMB)
	{
	  buffer_i = 0;
	}
      //      buffer_i = (buffer_i+1) % NUMB;
    }
#else

#if 0  
  // Turn our drive of the bus off
  drv_init();
#endif
  
  multicore_launch_core1(core1_main_3);
  //  irq_set_mask_enabled(0xffff, false);

  printf("\nReady\n");
  
  // Sit in a loop
  while(1)
    {
      process_bus();

      // Update the USB CLI
      serial_loop();
    }
  
#endif
}

